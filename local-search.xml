<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>索引的使用</title>
    <link href="/2021/10/24/%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/10/24/%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="B-树索引适用的条件"><a href="#B-树索引适用的条件" class="headerlink" title="B+树索引适用的条件"></a>B+树索引适用的条件</h3><p>举例说明,我们创建一个表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> person_info(<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> auto_increment,<br>name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>birthday <span class="hljs-type">DATE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>phone_number <span class="hljs-type">CHAR</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>country <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br><span class="hljs-keyword">PRIMARY</span> KEY (id),<br>KEY idx_name_birthday_phone_number (name, birthday, phone_number)<br>);<br></code></pre></td></tr></table></figure><p>可知,这个表会创建两个索引,一个聚簇索引和联合索引,聚簇索引如下图所示:<br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-02-25_13-52-53_1614232385407.png" alt="Snipaste_20210225_135253.png"></p><h4 id="全值匹配"><a href="#全值匹配" class="headerlink" title="全值匹配"></a>全值匹配</h4><p>如果搜索条件中的列和索引列一致的话,这种情况被称为全值匹配,比如说如下查找语句:  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;Ashburn&#x27;</span> <span class="hljs-keyword">AND</span> birthday = <span class="hljs-string">&#x27;1990-09-27&#x27;</span> <span class="hljs-keyword">AND</span> phone_num<br>ber = <span class="hljs-string">&#x27;15123983239&#x27;</span>;<br></code></pre></td></tr></table></figure><p>那么查询过程如下:  </p><ul><li>因为B+树的数据页和记录是先按照name列的值进行排序的,所以可以很快定位到name值是Ashburn的记录位置</li><li>在name列相同的记录里按照birthday值进行排序的,所以在name列的值是Ashburn里又快速定位到birthday是’1990-09-27’的记录,所以联合索引的3个列都可能会用到</li></ul><p>改变搜索条件的位置,对搜索顺序没影响,Mysql有个茶村优化器的东西,会分析搜索条件,并按照可以使用的索引的顺序来决定先使用哪个搜索条件.</p><h4 id="匹配左边的列"><a href="#匹配左边的列" class="headerlink" title="匹配左边的列"></a>匹配左边的列</h4><p>其实搜索也不用包含全部的列,只包含左边就行,比如下面的查询语句:  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;Ashburn&#x27;</span>;<br></code></pre></td></tr></table></figure><p>但是只有右边的搜索条件,就用不到索引,比如下面的搜索语句:  </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> birthday = <span class="hljs-string">&#x27;1990-09-27&#x27;</span>;<br></code></pre></td></tr></table></figure><p>因为name值不同的记录中,birthday可能是无序的,无法使用二分查找,所以如果我们想使用联合索引中尽可能多的列,搜索条件中的各个列必须是联合索引中从最左边连续的列.</p><h4 id="匹配列前缀"><a href="#匹配列前缀" class="headerlink" title="匹配列前缀"></a>匹配列前缀</h4><p>在页中需要对列进行排序,就需要用到列的排序规则,那么一个字符串的排序规则如下:  </p><ol><li>先按照字符串的第一个字符进行排序</li><li>如果第一个字符相同再按照第二个字符进行排序,以此类推</li></ol><p>也就是说这些字符串的前n个字符,前缀都是排好序的,所以对于字符串类型的索引列来说,我们只匹配前缀也是可以快速定位记录的,比如:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;As%&#x27;</span>;<br></code></pre></td></tr></table></figure><h4 id="匹配范围值"><a href="#匹配范围值" class="headerlink" title="匹配范围值"></a>匹配范围值</h4><p>比如下面的查询语句: </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> &gt; <span class="hljs-string">&#x27;Asa&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-type">name</span> &lt; <span class="hljs-string">&#x27;Barlow&#x27;</span>;<br></code></pre></td></tr></table></figure><p>查找过程如下:  </p><ol><li>找到name值为Asa的记录</li><li>找到name值为Barlow的记录</li><li>找到这些记录的主键值,再到聚簇索引中回表查找完整的记录</li></ol><p><strong>如果对多个列同时进行范围查找的话,只有对最左边的那个列进行范围查找的时候才能用到B+树索引</strong>,比如:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> &gt; <span class="hljs-string">&#x27;Asa&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-type">name</span> &lt; <span class="hljs-string">&#x27;Barlow&#x27;</span> <span class="hljs-keyword">AND</span> birthday &gt; <span class="hljs-string">&#x27;1980-01-0</span><br><span class="hljs-string">1&#x27;</span>;<br></code></pre></td></tr></table></figure><p>这个查询中通过name进行范围查找的记录可能并不是按照birthday列进行排序的,所以只能用到name列部分.  </p><h4 id="精确匹配某一列并范围匹配某一列"><a href="#精确匹配某一列并范围匹配某一列" class="headerlink" title="精确匹配某一列并范围匹配某一列"></a>精确匹配某一列并范围匹配某一列</h4><p>如果左边的列是精确查找,则右边的列可以进行范围查找,比如这样:  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;Ashburn&#x27;</span> <span class="hljs-keyword">AND</span> birthday &gt; <span class="hljs-string">&#x27;1980-01-01&#x27;</span> <span class="hljs-keyword">AND</span> birthday<br>&lt; <span class="hljs-string">&#x27;2000-12-31&#x27;</span> <span class="hljs-keyword">AND</span> phone_number &gt; <span class="hljs-string">&#x27;15100000000&#x27;</span>;<br></code></pre></td></tr></table></figure><p>因为name值相同,那么birthday是排序好的,所以birthday还可以用到索引,但是phone_number就不能 </p><h4 id="用于排序"><a href="#用于排序" class="headerlink" title="用于排序"></a>用于排序</h4><p>我们说说不能使用索引排序的情况,比如说这样的:  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-type">name</span>, birthday <span class="hljs-keyword">DESC</span> <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><ul><li>先从索引的最左边确定name列最小的值,然后找到name列等于该值得所有记录,然后从name列等于该值得最右边那条记录开始往左找10条记录</li><li>如果name列等于最小值得记录不足10条,再继续往右找name值第二小的记录,重复上边的过程,直到找到10条记录为止.</li></ul><p>mysql觉得这样不如直接文件排序来的快,所以就直接规定使用联合索引的排序列必须是一致的.  </p><p>要想使用索引进行排序,必须保证索引列是以单独列的形式出现,而不是修饰过的形式,比如:  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> UPPER(<span class="hljs-type">name</span>) <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><h4 id="回表的代价"><a href="#回表的代价" class="headerlink" title="回表的代价"></a>回表的代价</h4><p>因为我们创建的联合索引,没有包含所有的字段,所以在查询所有字段的时候需要一次回表操作,由于联合索引B+树中的记录会按照name列的值进行排序,所以值在Asa~Barlow之间的记录在磁盘中的存储是相连的,集中分布在一个或几个数据页中,可以很快的从磁盘中读出来,这种读取方式可以称为顺序IO,根据从联合索引获取到的主键字段,而这些主键可能不是连续的,所以在聚簇索引中可能需要访问不同的数据页,这种方式可以称为随机IO.<strong>需要回表的记录越多,使用二级索引的性能越低</strong>.<br>实际上查询优化器会帮助我们判断什么时候采用全表扫描,什么时候使用二级索引+回表方式,如果需要回表的记录越少,优化器就会倾向采用二级索引,比如像这样的查询:  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> &gt; <span class="hljs-string">&#x27;Asa&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-type">name</span> &lt; <span class="hljs-string">&#x27;Barlow&#x27;</span> <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><h4 id="如何挑选索引"><a href="#如何挑选索引" class="headerlink" title="如何挑选索引"></a>如何挑选索引</h4><h5 id="只为用于搜索-排序-或者分组的列创建索引"><a href="#只为用于搜索-排序-或者分组的列创建索引" class="headerlink" title="只为用于搜索,排序,或者分组的列创建索引"></a>只为用于搜索,排序,或者分组的列创建索引</h5><p>也就是说,只为出现在where字句中的列,连接字句中的连接列,或者出现在order by或者group by 字句中列创建索引 </p><h5 id="考虑列的基数"><a href="#考虑列的基数" class="headerlink" title="考虑列的基数"></a>考虑列的基数</h5><p>列的基数 指的是某一列中不重复数据的个数，比方说某个列包含值 2, 5, 8, 2, 5, 8, 2, 5, 8 ，虽然有 9 条记录，但该列的基数却是 3 。也就是说，在记录行数一定的情况下，列的基数越大，该列中的值越分散，列的基数越小，该列中的值越集中。这个 列的基数 指标非常重要，直接影响我们是否能有效的利用索引。假设某个列的基数为 1 ，也就是所有记录在该列中的值都一样，那为该列建立索引是没有用的，因为所有值都一样就无法排序，无法进行快速查找了～ 而且如果某个建立了二级索引的列的重复值特别多，那么使用这个二级索引查出的记录还可能要做回表操作，这样性能损耗就更大了。所以结论就是：最好为那些列的基数大的列建立索引，为基数太小列的建立索引效果可能不好。</p><h5 id="索引列的类型尽量小"><a href="#索引列的类型尽量小" class="headerlink" title="索引列的类型尽量小"></a>索引列的类型尽量小</h5><p>我们在定义表结构的时候要显式的指定列的类型，以整数类型为例，有 TINYINT 、 MEDIUMINT 、 INT 、 BIGINT这么几种，它们占用的存储空间依次递增，我们这里所说的 类型大小 指的就是该类型表示的数据范围的大小。能表示的整数范围当然也是依次递增，如果我们想要对某个整数列建立索引的话，在表示的整数范围允许的情况下，尽量让索引列使用较小的类型，比如我们能使用 INT 就不要使用 BIGINT ，能使用 MEDIUMINT 就不要使用INT ～ 这是因为：</p><ul><li>数据类型越小，在查询时进行的比较操作越快 </li><li>数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘 I/O 带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。</li></ul><h5 id="索引字符串的前缀"><a href="#索引字符串的前缀" class="headerlink" title="索引字符串的前缀"></a>索引字符串的前缀</h5><p>我们知道一个字符串其实是由若干个字符组成，如果我们在 MySQL 中使用 utf8 字符集去存储字符串的话，编码一个字符需要占用 1~3 个字节。假设我们的字符串很长，那存储一个字符串就需要占用很大的存储空间。在我们需要为这个字符串列建立索引时，那就意味着在对应的 B+ 树中有这么两个问题：</p><ul><li>B+ 树索引中的记录需要把该列的完整字符串存储起来，而且字符串越长，在索引中占用的存储空间越大。</li><li>如果 B+ 树索引中索引列存储的字符串很长，那在做字符串比较时会占用更多的时间。</li></ul><p>我们前边儿说过索引列的字符串前缀其实也是排好序的，所以索引的设计者提出了个方案 — 只对字符串的前几个字符进行索引也就是说在二级索引的记录中只保留字符串前几个字符。这样在查找记录时虽然不能精确的定位到记录的位置，但是能定位到相应前缀所在的位置，然后根据前缀相同的记录的主键值回表查询完整的字符串值，再对比就好了。这样只在 B+ 树中存储字符串的前几个字符的编码，既节约空间，又减少了字符串的比较时间，还大概能解决排序的问题，何乐而不为，比方说我们在建表语句中只对 name 列的前10个字符进行索引可以<br>这么写：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> person_info(<br>name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>birthday <span class="hljs-type">DATE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>phone_number <span class="hljs-type">CHAR</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>country <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>KEY idx_name_birthday_phone_number (name(<span class="hljs-number">10</span>), birthday, phone_number)<br>);<br></code></pre></td></tr></table></figure><p>name(10) 就表示在建立的 B+ 树索引中只保留记录的前 10 个字符的编码，这种只索引字符串值的前缀的策略是我们非常鼓励的，尤其是在字符串类型能存储的字符比较多的时候。如果使用了索引列前缀，比方说前边只把 name 列的前10个字符放到了二级索引中,如果需要对name值进行排序,就无法使用二级索引了.</p><h5 id="让索引列在比较表达式中单独出现"><a href="#让索引列在比较表达式中单独出现" class="headerlink" title="让索引列在比较表达式中单独出现"></a>让索引列在比较表达式中单独出现</h5><p>假设表中有一个整数列 my_col ，我们为这个列建立了索引。下边的两个 WHERE 子句虽然语义是一致的，但是在效率上却有差别：</p><ol><li>WHERE my_col * 2 &lt; 4</li><li>WHERE my_col &lt; 4/2</li></ol><p>第1个 WHERE 子句中 my_col 列并不是以单独列的形式出现的，而是以 my_col * 2 这样的表达式的形式出现的，存储引擎会依次遍历所有的记录，计算这个表达式的值是不是小于 4 ，所以这种情况下是使用不到为 my_col 列建立的 B+ 树索引的。而第2个 WHERE 子句中 my_col 列并是以单独列的形式出现的，这样的情况可以直接使用B+ 树索引。</p><p>所以结论就是：如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出现的话，是用不到索引的。</p><h5 id="主键插入顺序"><a href="#主键插入顺序" class="headerlink" title="主键插入顺序"></a>主键插入顺序</h5><p>我们知道，对于一个使用 InnoDB 存储引擎的表来说，在我们没有显式的创建索引时，表中的数据实际上都是存储在 聚簇索引 的叶子节点的。而记录又是存储在数据页中的，数据页和记录又是按照记录主键值从小到大的顺序进行排序，所以如果我们插入的记录的主键值是依次增大的话，那我们每插满一个数据页就换到下一个数据页继续插，而如果我们插入的主键值忽大忽小的话，这就比较麻烦了，假设某个数据页存储的记录已经满了，它存储的主键值在 1~100 之间：<br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-02-26_14-30-22_1614321074335.png" alt="Snipaste_20210226_143022.png"></p><p> 如果此时再插入一条主键值为 9 的记录，那它插入的位置就如下图：<br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-02-26_14-31-27_1614321097429.png" alt="Snipaste_20210226_143127.png"><br>可这个数据页已经满了啊，再插进来咋办呢？我们需要把当前页面分裂成两个页面，把本页中的一些记录移动到新创建的这个页中。页面分裂和记录移位意味着什么？意味着：性能损耗！所以如果我们想尽量避免这样无谓的性能损耗，最好让插入的记录的主键值依次递增，这样就不会发生这样的性能损耗了。所以我们建议：让主键具有 AUTO_INCREMENT ，让存储引擎自己为表生成主键，而不是我们手动插入.</p><h5 id="冗余和重复索引"><a href="#冗余和重复索引" class="headerlink" title="冗余和重复索引"></a>冗余和重复索引</h5><p>有时候有的同学有意或者无意的就对同一个列创建了多个索引，比方说这样写建表语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> person_info(<br>id <span class="hljs-type">INT</span> UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>birthday <span class="hljs-type">DATE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>phone_number <span class="hljs-type">CHAR</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>country <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br><span class="hljs-keyword">PRIMARY</span> KEY (id),<br>KEY idx_name_birthday_phone_number (name(<span class="hljs-number">10</span>), birthday, phone_number),<br>KEY idx_name (name(<span class="hljs-number">10</span>))<br>);<br></code></pre></td></tr></table></figure><p>我们知道，通过 idx_name_birthday_phone_number 索引就可以对 name 列进行快速搜索，再创建一个专门针对name 列的索引就算是一个 冗余 索引，维护这个索引只会增加维护的成本，并不会对搜索有什么好处。<br>另一种情况，我们可能会对某个列重复建立索引，比方说这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> repeat_index_demo (<br>c1 <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>c2 <span class="hljs-type">INT</span>,<br><span class="hljs-keyword">UNIQUE</span> uidx_c1 (c1),<br>INDEX idx_c1 (c1)<br>);<br></code></pre></td></tr></table></figure><p>c1 既是主键、又给它定义为一个唯一索引，还给它定义了一个普通索引，可是主键本身就会生成聚<br>簇索引，所以定义的唯一索引和普通索引是重复的，这种情况要避免</p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mysql数据行格式</title>
    <link href="/2021/10/24/Mysql%E6%95%B0%E6%8D%AE%E8%A1%8C%E6%A0%BC%E5%BC%8F/"/>
    <url>/2021/10/24/Mysql%E6%95%B0%E6%8D%AE%E8%A1%8C%E6%A0%BC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="InnnDB行格式"><a href="#InnnDB行格式" class="headerlink" title="InnnDB行格式"></a>InnnDB行格式</h2><p>MySQL服务器上负责对表中的数据读取和写入工作的部分是<strong>存储引擎</strong>,我们常用的存储引擎InnoDB,真实数据在不同存储引擎中存放的格式一般是不同的,InnoDB真正处理数据的过程是发生在内存中的,所以需要把磁盘的数据加载到内存中,如果是处理写入或者修改请求的话,还需要把内存中的记录刷新到磁盘上,磁盘的读写速度和内存相比非常慢,所以InnoDB采取的方式是:<strong>将数据划分为若干个页,以页作为磁盘和内存之间交互的基本单位,InnoDB中页的大小一般为16KB</strong>,也就是说,一次最少从磁盘读取16KB的内容到内存中,一次最少把内存中的16KB内存刷新到磁盘中。数据是以记录插入到表中的,记录的存放方式也被称为行格式,InnoDB有4种行格式,分别是<strong>Compact,Redundant,Dynamic,Compressed</strong> </p><h3 id="Compact行格式"><a href="#Compact行格式" class="headerlink" title="Compact行格式"></a>Compact行格式</h3><p><img src="https://199794.oss-cn-shanghai.aliyuncs.com/blog//snipaste_20201224_133417_1608788072352.png" alt="snipaste_20201224_133417.png"></p><h4 id="记录的额外信息"><a href="#记录的额外信息" class="headerlink" title="记录的额外信息"></a>记录的额外信息</h4><p>这里是描述记录的元信息,分别是变长字段长度列表,NULL值列表和记录头信息.<br>我们知道常用的一些变长数据类型,比如VARCHAR(M),VABINARY(M)等,变长字段存储多少字节的数据是不固定的,所以在存储真实数据的时候把数据占用的字节也存储起来.<br>创建一个示例: </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> record_format_demo (<br><span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> c1 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>),<br><span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> c2 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br><span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> c3 <span class="hljs-type">CHAR</span>(<span class="hljs-number">10</span>),<br><span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> c4 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>)<br><span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> ) CHARSET<span class="hljs-operator">=</span>ascii ROW_FORMAT<span class="hljs-operator">=</span>COMPACT;<br></code></pre></td></tr></table></figure><p>表中数据如下:<br><img src="https://199794.oss-cn-shanghai.aliyuncs.com/blog//snipaste_20201224_134654_1608788828570.png" alt="snipaste_20201224_134654.png"><br>在Compact行格式中,把所有变长字段的真实数据占用字节长度存放在记录的开头部位,从而形成一个变长字段长度列表,各变长字段数据占用的字节数按照列的顺序逆序存放,从这个例子来看,c1、c2、c4列都是变长类型的，都采用ascii字符集，所以每个字符只需要一个字节来编码，看一下，列的长度：<br><img src="https://199794.oss-cn-shanghai.aliyuncs.com/blog//snipaste_20201224_142251_1608790980798.png" alt="snipaste_20201224_142251.png"><br>查看一下记录实际效果：<br><img src="https://199794.oss-cn-shanghai.aliyuncs.com/blog//snipaste_20201224_142251_1608791049227.png" alt="snipaste_20201224_142251.png"></p><p>对于变长类型VARCHAR（M）来说，这种类型表示能存储最多M个字符，所以这个类型能表示的字符串最多占用的字节数就是M乘以编码最大表示字节数，比如utf8是3，utf8mb64是4，**如果该可变字段允许存储的最大字节数（M × W ）超过255字节并且真实存储的字节数（L）超过127字节，则使用2个字节，否则使用1个字节。  </p><p>需要注意：变长字段长度列表只存储值为非NULL的列内容占用的长度，值为NULL的列的长度是不存储的。</p><h4 id="NULL值列表"><a href="#NULL值列表" class="headerlink" title="NULL值列表"></a>NULL值列表</h4><p>表中某些列可能存储NULL值，如果把这些NULL值都放到记录的真实数据中存储会很占地方，所以Compact行格式把这些值为NULL的列统一管理起来，存储到NULL值列表中，处理过程如下：  </p><ol><li>统计表中的NULL值有哪些 </li><li>如果表中没有运行存储NULL的列，则NULL值列表也不存在了，否则将每个允许存储NULL的列对应一个二进制位，二进制位按照列的顺序逆序排列，1表示该列为null，0表示该列不为null。</li><li>规定NULL值列表必须用整个字节的位表示，如果使用的二进制位个数不是整个字节，则在字节的高位补0.</li></ol><p><img src="https://199794.oss-cn-shanghai.aliyuncs.com/blog//snipaste_20201224_142251_1608796397248.png" alt="snipaste_20201224_142251.png"></p><h4 id="记录头信息"><a href="#记录头信息" class="headerlink" title="记录头信息"></a>记录头信息</h4><p>除了变长字段长度列表，NULL值列表之外，还有一个用于描述记录的记录头信息，他是由固定的5个字节组成：<br><img src="https://199794.oss-cn-shanghai.aliyuncs.com/blog//snipaste_20201224_142251_1608796598727.png" alt="snipaste_20201224_142251.png">  </p><p><img src="https://199794.oss-cn-shanghai.aliyuncs.com/blog//snipaste_20201224_155719_1608796650444.png" alt="snipaste_20201224_155719.png"></p><h4 id="记录的真实数据"><a href="#记录的真实数据" class="headerlink" title="记录的真实数据"></a>记录的真实数据</h4><p>MySQL会为每个记录默认的添加一些列（隐藏列），具体如下：  </p><p><img src="https://199794.oss-cn-shanghai.aliyuncs.com/blog//snipaste_20201224_155929_1608796780750.png" alt="snipaste_20201224_155929.png"></p><p> InnoDB 表对主键的生成策略：优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个 Unique 键作为主键，如果表中连 Unique 键都没有定义的话，则 InnoDB 会为表默认添加一个名row_id 的隐藏列作为主键。所以我们从上表中可以看出：InnoDB存储引擎会为每条记录都添加 transaction_id和 roll_pointer 这两个列，但是 row_id 是可选的（在没有自定义主键以及Unique键的情况下才会添加该列）。这些隐藏列的值不用我们操心， InnoDB 存储引擎会自己帮我们生成的</p><p>因为例子没有定义主键,所以会为每条记录增加上述的3个列：<br><img src="https://199794.oss-cn-shanghai.aliyuncs.com/blog//snipaste_20201224_155929_1608797030169.png" alt="snipaste_20201224_155929.png"><br>注意几点：  </p><ol><li>表使用的是 ascii 字符集，所以 0x61616161 就表示字符串 ‘aaaa’ 0x626262 就表示字符串 ‘bbb’ </li><li>注意第1条记录中 c3 列的值，它是 CHAR(10) 类型的，它实际存储的字符串是： ‘cc’ ，而 ascii 字符集中的字节表示是 ‘0x6363’ ，虽然表示这个字符串只占用了2个字节，但整个 c3 列仍然占用了10个字节的空间，除真实数据以外的8个字节的统统都用空格字符填充，空格字符在 ascii 字符集的表示就是 0x20 </li><li>注意第2条记录中 c3 和 c4 列的值都为 NULL ，它们被存储在了前边的 NULL值列表 处，在记录的真实数据处就不再冗余存储，从而节省存储空间  </li></ol><h4 id="char-M-的存储格式"><a href="#char-M-的存储格式" class="headerlink" title="char(M)的存储格式"></a>char(M)的存储格式</h4><p>如果char(M)的字符集采用的也是变长字符集的话，也会记录到变长字段长度列表，</p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>了解迭代器</title>
    <link href="/2021/10/24/%E4%BA%86%E8%A7%A3%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <url>/2021/10/24/%E4%BA%86%E8%A7%A3%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>就是提供一种方法对一个容器对象中的各个元素进行访问,而又不暴露该对象容器的内部细节  </p><p>比如对于数据的遍历  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">int</span> <span class="hljs-keyword">array</span>[] = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">3</span>];    <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">array</span>.length; i++) &#123;<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">array</span>[i]);<br>&#125;<br></code></pre></td></tr></table></figure><p>对ArrayList的处理  </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">List</span>&lt;<span class="hljs-keyword">String</span>&gt; <span class="hljs-keyword">list</span> = <span class="hljs-keyword">new</span> ArrayList&lt;<span class="hljs-keyword">String</span>&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-keyword">list</span>.size() ;  i++)&#123;<br>           <span class="hljs-keyword">String</span> <span class="hljs-keyword">string</span> = <span class="hljs-keyword">list</span>.get(i);<br>&#125;<br>```    <br>对于这两种方式,我们知道他的内部结构,访问集合和集合本身是紧密耦合的,无法将访问逻辑和集合代码分离出来,不同的集合对应不同的访问方法,但是**<span class="hljs-built_in">Iterator</span>**,它总是用同一种逻辑来遍历集合,集合的内部状态由<span class="hljs-built_in">Iterator</span>来维护,客户端不用直接和集合打交道<br><br><span class="hljs-comment">### Iterable接口  </span><br><br><span class="hljs-keyword">Iterable</span>接口实现的功能是返回一个迭代器,该接口的<span class="hljs-built_in">iterator</span>()方法返回一个标准的<span class="hljs-built_in">Iterator</span>实现,实现<span class="hljs-keyword">Iterable</span>接口允许对象成为<span class="hljs-keyword">Foreach</span>语句的目标,就可以用过<span class="hljs-keyword">foreach</span>语句来遍历你的底层序列  <br><br>看看JDK8中定义的<span class="hljs-keyword">Iterable</span>接口<br></code></pre></td></tr></table></figure><p>public interface Iterable<T> {</p><p>//返回一个迭代器<br>Iterator<T> iterator();</p><p>default void forEach(Consumer&lt;? super T&gt; action) {<br>        Objects.requireNonNull(action);<br>        for (T t : this) {<br>            action.accept(t);<br>        }</p><p> default Spliterator<T> spliterator() {<br>        return Spliterators.spliteratorUnknownSize(iterator(), 0);<br>    }</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><br><span class="hljs-keyword">iterator</span>方法返回一个<span class="hljs-keyword">Iterator</span>接口 ,我们看看<span class="hljs-keyword">Iterator</span>接口:  <br><br></code></pre></td></tr></table></figure><p>public interface Iterator<E> {</p><p>  boolean hasNext();</p><p>  E next();</p><p>  default void remove() {<br>        throw new UnsupportedOperationException(“remove”);<br>  }</p><p>  default void forEachRemaining(Consumer&lt;? super E&gt; action) {<br>        Objects.requireNonNull(action);<br>        while (hasNext())<br>            action.accept(next());<br>  } </p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">简单实现一个迭代器:</span><br></code></pre></td></tr></table></figure><p>public class Test {</p><pre><code>public static void main(String[] args) &#123;    ReverseList&lt;String&gt; list=new ReverseList();    list.add(&quot;111&quot;);    list.add(&quot;222&quot;);    list.add(&quot;333&quot;);    Iterator&lt;String&gt; iterator = list.iterator();    while (iterator.hasNext())&#123;        System.out.println(iterator.next());    &#125;&#125;</code></pre><p>}</p><p>class ReverseList<T> implements Iterable<T> {</p><pre><code>private List&lt;T&gt; list = new ArrayList&lt;&gt;();public void add(T data) &#123;    list.add(data);&#125;@Overridepublic Iterator&lt;T&gt; iterator() &#123;    return new ReverIterator(list.size());&#125;private class ReverIterator implements Iterator&lt;T&gt; &#123;    int index;    ReverIterator(int size) &#123;        this.index = size;    &#125;    @Override    public void remove() &#123;        list.remove(index);    &#125;    @Override    public boolean hasNext() &#123;        return index&gt;0;    &#125;    @Override    public T next() &#123;        index--;        return list.get(index);    &#125;&#125;</code></pre><p>}</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><br><span class="hljs-comment">### 遍历元素</span><br><br>Java8为<span class="hljs-keyword">Iterable</span>接口新增了一个<span class="hljs-keyword">forEach</span>(Consumer action)方法,查看源码,其内部也是使用的 <span class="hljs-keyword">for</span> each遍历,在上面的例子中,我们使用<span class="hljs-keyword">Foreach</span>遍历<br></code></pre></td></tr></table></figure><p> ReverseList<String> list=new ReverseList();<br>        list.add(“111”);<br>        list.add(“222”);<br>        list.add(“333”);</p><pre><code>    list.forEach(x-&gt; System.out.println(x));</code></pre><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">也将得出反序的元素输出<br><br><span class="hljs-keyword">Java8为iterator新增的默认forEachRemaining方法,该方法可以用lamdba遍历集合 </span> <br><br></code></pre></td></tr></table></figure><p>ReverseList<String> list=new ReverseList();<br>        list.add(“111”);<br>        list.add(“222”);<br>        list.add(“333”);<br>Iterator<String> iterator = list.iterator();<br>iterator.forEachRemaining(x-&gt; System.out.println(x));</p><pre><code>### 快速失败机制当使用Iterator迭代访问Collection集合元素时,Collection集合里的元素不能被改变(**只有改变集合个数才会引发,使用list.set(index,element)方法改变某个元素时不会引发**),只有通过Iterator的remove()方法删除上一次next()方法返回的集合元素才可以,否则将会引发ModificationException异常.    </code></pre>]]></content>
    
    
    <categories>
      
      <category>JDK</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库与文件系统</title>
    <link href="/2021/10/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2021/10/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="数据库文件系统"><a href="#数据库文件系统" class="headerlink" title="数据库文件系统"></a>数据库文件系统</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">SHOW <span class="hljs-keyword">VARIABLES</span> LIKE <span class="hljs-comment">&#x27;datadir&#x27;</span>;<br></code></pre></td></tr></table></figure><p>可以查看数据库文件存储的位置 ,每个数据库都对应数据目录下的一个子目录，或者说对应一个文件夹，我们每当我们新建一个数据库时， MySQL 会帮我们做这两件事儿：</p><ol><li>在 数据目录 下创建一个和数据库名同名的子目录（或者说是文件夹）。</li><li>在该与数据库名同名的子目录下创建一个名为 db.opt 的文件，这个文件中包含了该数据库的各种属性，比方说该数据库的字符集和比较规则是个啥。</li></ol><h4 id="innodb是如何存储表数据的"><a href="#innodb是如何存储表数据的" class="headerlink" title="innodb是如何存储表数据的"></a>innodb是如何存储表数据的</h4><ol><li>innoDB是使用页为基本单位来管理存储空间的,默认页的大小为16kb.</li><li>对于InnoDB来说,每个索引都对应者一颗B+树,该B+树的每个节点都是一个数据页,数据页之间不必要是物理连续的,因为数据页之间有双向链表来维护着这些页的顺序.</li><li>InnoDB的聚簇索引的叶子节点存储了完整的用户记录,也就是所谓的索引即数据,数据即索引.</li></ol><p>为了管理这些页,设计们提出了表空间或文件空间的概念,表空间是一个抽象的概念,可以对应文件系统上一个或者多个真实文件,每个表空间可以被划分为很多很多页.表空间有不同的类型,下面来看看:</p><h5 id="系统表空间"><a href="#系统表空间" class="headerlink" title="系统表空间"></a>系统表空间</h5><p>系统表空间对应文件系统上一个或多个实际的文件,我们表中的数据都会被默认存储到这个系统表空间. InnoDB不会把各个表的数据存储到系统表空间中,而是为每一个表建立一个独立表空间,使用独立表空间会在该表所属的子目录下创建一个文件名和表名相同的扩展名为.ibd的文件.  </p><p>比方说假如我们使用独立表空间去存储xiaohaizi数据库下的test表,那么会在xiaohaizi目录下创建test.frm与test.idb</p><p>数据目录下有还一些其他文件: </p><ul><li>服务器进程文件</li><li>服务器日志文件<br>  比如常规的查询日志,错误日志,二进制日志,redo日志</li><li>默认/自动生成的SSL和RSA证书和密钥文件 </li></ul><h3 id="InnoDB的表空间"><a href="#InnoDB的表空间" class="headerlink" title="InnoDB的表空间"></a>InnoDB的表空间</h3><p>表空间中存储了各种页 </p><h4 id="区"><a href="#区" class="headerlink" title="区"></a>区</h4><p>为了更好的管理页,InnoDB设计者提出了区的概念,连续的64个页就是区(也就是一个区默认占用1MB空间大小),每256个区划分成1组,大概如下图所示:<br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-02-27_13-05-49_1614402368978.png" alt="Snipaste_20210227_130549.png">   </p><p><strong>为什么要引入区的概念?</strong><br>我们每向表中插入一条记录,本质上就是向该表的聚簇索引以及所有二级索引代表的B+树的节点插入数据,而B+树的每一层的页都会形成一个双向链表,如果是以页为单位来分配存储空间的话,双向链表相邻的两个页之间的物理位置可能隔的非常远,如果链表中相邻的两个页的物理位置离的非常远,就是所谓的随机IO,所以应该让链表中相邻的页的物理位置也相邻,这样可以使用所谓的顺序IO,所以才引入了区的概念,一个区就是在物理位置上连续的64个页,为某个索引分配空间的时候不再按照页为单位分配了,而是按照区为单位分配,甚至在表数据非常多的时候,可以一次性分配多个连续的区,虽然可能造成空间浪费,但是可以提高性能.  </p><p>我们知道范围查询其实是对B+树叶子节点中的记录进行顺序扫描,而如果不区分叶子节点和非叶子节点,统统把节点代表的页面放到区中,进行范围扫描效果就没有那么好,所以叶子节点有自己独有的区,非叶子节点也有自己独有的区存放叶子节点的区的集合就算一个段,存放非叶子节点的区的集合也算一个段,也就是索引会生成两个段,一个叶子节点段,一个非叶子节点段.  </p><h4 id="区的分类"><a href="#区的分类" class="headerlink" title="区的分类"></a>区的分类</h4><ul><li>空闲的区:现在还没有用到这个区的任何页面</li><li>有剩余空间的碎片区:表示碎片区中还有可用的页面</li><li>没有剩余空间的碎片区:表示碎片区中的所有页面都可以被使用,没有空闲页面.</li><li>附属于某个段的区.每个索引都可以分为叶子节点和非叶子节点,还有一些特殊作用的段.  </li></ul><p>为了方便管理这些区,设计了一个XDEC Entry的结构,每个区都对应着一个XDEC Entry结构,这个结构对应了区的一些属性,<br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-05-20_21-54-45_1621518904737.png" alt="Snipaste_20210520_215445.png"></p><ul><li>Segment ID<br>每一个段都有一个唯一编号,这里表示该区所在的段 </li><li>List Node<br>这个部分可以将XDES Entry结构组成一个链表  </li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>B+树索引</title>
    <link href="/2021/10/24/B-%E6%A0%91%E7%B4%A2%E5%BC%95/"/>
    <url>/2021/10/24/B-%E6%A0%91%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<p>对于非主键的查找过程是如何? </p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>如果想要快速的找到数据在哪个页,我没必须为数据页也建立一个目录,建这个目录必须完成下面这些事:  </p><ul><li>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值. </li></ul><p>下面展示数据页模型的简单示例:<br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-02-24_23-52-00_1614181930113.png" alt="Snipaste_20210224_235200.png"><br> 黄色代表主键,由于数据页不是连续的,在向表中插入许多数据后,可能是这样的效果:<br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-02-24_23-54-45_1614182094657.png" alt="Snipaste_20210224_235445.png"><br>下面我们为这几个页做目录,每个目录项包含以下内容:  </p><ol><li>页的用户记录中最小的主键值,我们用key表示</li><li>页号,我们用page_no表示</li></ol><p><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-02-24_23-56-59_1614182231093.png" alt="Snipaste_20210224_235659.png"> </p><p>比方说我们想找主键值为20的记录,查找过程分两步:  </p><ul><li>从目录项中根据二分法确定主键值为20的记录在目录3(12&lt;20&lt;209),它对应的页是页9.</li><li>再在页内定位具体的记录.</li></ul><p>我们上面假设的是目录项在物理上连续存储的,假如某个页面删除了,那么后面的目录项都需要向前移动,这种设计导致牵一发而动全身,所以设计者复用了之前存储用户记录的数据页来存储目录项,为了和用户记录做区分,使用record_type=1来记录,如下图所示:<br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-02-25_09-43-24_1614217415599.png" alt="Snipaste_20210225_094324.png">  </p><p>一个页的大小为16kb,如果一个页放不下所有的目录项,则需要多个页来存储,如下图所示:<br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-02-25_09-49-14_1614217764039.png" alt="Snipaste_20210225_094914.png">  </p><p>我们现在查询需要定位到目录项记录的页,那么我们怎么根据主键值快速定位到存储目录项记录的页呢,可以继续为目录项记录再生成一个高级记录页,如下图所示: </p><p><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-02-25_09-53-56_1614218049365.png" alt="Snipaste_20210225_095356.png"><br>这其实就是一个B+树,实际的用户记录其实都存放在B+树的最底层节点上,也就是叶子节点,其余用来存储目录项的节点称为非叶子节点.  </p><h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><ol><li>使用记录主键值的大小进行记录和页的排序,包括三方面的含义: <ul><li>页内的记录按照主键大小顺序排成一个单项链表</li><li>各个存放用户记录的页根据用户记录的主键大小顺序排成一个双向链表</li><li>存放目录项记录放在不同层次,在同一层次中的页也是根据页中目录项记录的主键大小排成一个双向链表</li></ul></li><li>B+树的叶子节点存储的是完整的用户记录(就是指这个记录存储了所以列的值)</li></ol><p>聚簇索引并不需要我们使用index语句去创建,InnoDB存储引擎会自动的为我们创建聚簇索引,在InnoDB存储引擎中,聚簇索引就是数据的存储方式,也就是所谓的索引即数据,数据即索引.   </p><h4 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h4><p>如果我们想用别的列作为搜索条件,我们可以再新建一个B+树,比如说我们使用C2列的大小作为数据页,页中记录的排序规则,再新建一个B+树,如下图所示:<br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-02-25_10-14-06_1614219266875.png" alt="Snipaste_20210225_101406.png"></p><p>这个B+树与聚簇索引的不同之处: </p><ul><li><p>使用记录c2列的大小进行记录和页的排序,包含3个方面的含义:  </p><ul><li>页内记录是按照c2列大小顺序排成一个单向链表</li><li>各个存放用户记录的页也是根据页中记录的c2列大小顺序排成一个双向链表</li><li>存放目录项记录的页分为不同的层次,在同一层次中的页也是根据页中目录项记录的c2大小顺序排成双向链表</li></ul></li><li><p>B+树的叶子节点存储的不是完整的用户记录,而只是c2列+主键 这两个列的值</p></li><li><p>目录项记录中不再是主键+页号,而是c2+页号</p></li></ul><p>现在根据c2(查找c2=4)查找过程如下: </p><ol><li>确定目录项记录页(可以快速定位到目录项记录所在的页内42,因为2&lt;4&lt;9)</li><li>通过目录项记录页确定用户记录真实所在的页,可以确定在页34和35中</li><li>在页中定位到具体的记录,由于叶子节点只存储了c2和c1,所以我们必须再根据主键去聚簇索引中再查找一遍完整的用户记录,这个过程也称为<strong>回表</strong></li></ol><p>因为这种按照非主键建立的B+树需要一次回表操作才可以定位到完整的记录,所以这种B+树也被称为二级索引,或者辅助索引.</p><h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>我们也可以同时以多个列的大小作为排序规则,也就是同时为多个列建立索引,比如让B+树按照c2列和c3列的大小进行排序: </p><ul><li>先把各个记录和页按照c2列进行排序</li><li>在记录的c2列相同的情况下,采用c3列进行排序.</li></ul><p><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-02-25_13-15-00_1614230113213.png" alt="Snipaste_20210225_131500.png">  </p><h4 id="建立索引"><a href="#建立索引" class="headerlink" title="建立索引"></a>建立索引</h4><p>InnoDB和MyISAM会自动为主键或者声明为UNIQUE的列去自动建立B+数索引,或者手动建立:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> index_demo(<br>c1 <span class="hljs-type">INT</span>,<br>c2 <span class="hljs-type">INT</span>,<br>c3 <span class="hljs-type">CHAR</span>(<span class="hljs-number">1</span>),<br><span class="hljs-keyword">PRIMARY</span> KEY(c1),<br>INDEX idx_c2_c3 (c2, c3)<br>);<br><br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ADD</span> [INDEX<span class="hljs-operator">|</span>KEY] 索引名 (需要被索引的单个列或多个列);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>从数据页到索引</title>
    <link href="/2021/10/24/%E4%BB%8E%E6%95%B0%E6%8D%AE%E9%A1%B5%E5%88%B0%E7%B4%A2%E5%BC%95/"/>
    <url>/2021/10/24/%E4%BB%8E%E6%95%B0%E6%8D%AE%E9%A1%B5%E5%88%B0%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h4 id="数据页"><a href="#数据页" class="headerlink" title="数据页"></a>数据页</h4><p>数据页是InnoDB管理内存空间的基本单位，InnoDB有不同类型的页，比如存放头部空间的页，存放node信息的页，存放undo日志的页，存放表中记录的页，被官方称为索引。  </p><h4 id="数据页的结构"><a href="#数据页的结构" class="headerlink" title="数据页的结构"></a>数据页的结构</h4><p><img src="https://199794.oss-cn-shanghai.aliyuncs.com/blog//snipaste_20201228_203542_1609158949200.png" alt="snipaste_20201228_203542.png"><br>看一下各个部分的简单介绍<br><img src="https://199794.oss-cn-shanghai.aliyuncs.com/blog//snipaste_20201228_203729_1609159062208.png" alt="snipaste_20201228_203729.png"><br>我们自己存储的记录会按指定的行格式存储到User Records部分，每插入一条记录，都会从Free Space 部分，也就是尚未使用的存储空间申请一个记录大小空间划分到User Records部分。  </p><p>创建一个案例： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> page_demo(<br><span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> c1 <span class="hljs-type">INT</span>,<br><span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> c2 <span class="hljs-type">INT</span>,<br><span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> c3 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10000</span>),<br><span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">PRIMARY</span> KEY (c1)<br><span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> ) CHARSET<span class="hljs-operator">=</span>ascii ROW_FORMAT<span class="hljs-operator">=</span>Compact;<br></code></pre></td></tr></table></figure><p>看一下示例表的行格式：<br><img src="https://199794.oss-cn-shanghai.aliyuncs.com/blog//snipaste_20201228_211835_1609161553051.png" alt="snipaste_20201228_211835.png"><br>我们再复习下记录头信息里的各个属性：<br><img src="https://199794.oss-cn-shanghai.aliyuncs.com/blog//snipaste_20201228_214340_1609163036258.png" alt="snipaste_20201228_214340.png"><br>我们向表中插入几条数据：  </p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">mysql</span>&gt; <span class="hljs-selector-tag">INSERT</span> <span class="hljs-selector-tag">INTO</span> <span class="hljs-selector-tag">page_demo</span> <span class="hljs-selector-tag">VALUES</span>(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;aaaa&#x27;</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">200</span>, <span class="hljs-string">&#x27;bbbb&#x27;</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">300</span>, <span class="hljs-string">&#x27;cccc&#x27;</span>),<br>(<span class="hljs-number">4</span>, <span class="hljs-number">400</span>, <span class="hljs-string">&#x27;dddd&#x27;</span>);<br></code></pre></td></tr></table></figure><p><img src="https://199794.oss-cn-shanghai.aliyuncs.com/blog//snipaste_20201228_220219_1609164157246.png" alt="snipaste_20201228_220219.png"></p><p><strong>delete_mask</strong>:<br>标志着数据是否被删除，所有被删除的记录都会组成一个垃圾链表，这个链表被称为<strong>可重用空间</strong>，如果之后又新记录插入到表中，可能把这些空间覆盖掉<br><strong>min_rec_mask</strong>:<br>B+树的每层非叶子节点中的最小记录都会添加该记录，插入的4条记录的min_rec_mask值都是0，意味着他们都不是B+书的非叶子节点中的最小记录。<br><strong>heap_no</strong>:<br> 表示当前记录在本页中的位置，InnoDB存在两个伪记录，一个代表最小记录，一个代表最大记录，记录怎么比大小，比较记录的大小就是比较主键的大小，但是不管向页中插入多少记录，两条伪纪录都是固定的，如图所示：<br><img src="https://199794.oss-cn-shanghai.aliyuncs.com/blog//snipaste_20201229_232318_1609255411366.png" alt="snipaste_20201229_232318.png"><br>这两条记录被单独放在Infimum+Supremum部分。 最小记录和最大记录的heap_no值分别是0和1，也就是说他们的位置最靠前。<br><strong>record_type</strong>:<br>这个属性表示记录的类型，0表示普通记录，1表示B+书非叶子节点记录，2表示最小记录，3表示最大记录。<br><strong>next_record</strong>:<br>表示从当前记录的真实数据到下一条记录真实数据的地址偏移量,可以通过一条记录找到它的一条记录,这其实是个链表,下一条记录指的并不是按照我们插入顺序的下一条记录,而是按照主键值由小到大的顺序的下一条记录,而且规定最小记录的下一条记录就是本页中主键值最小的用户记录,而本页中主键值最大的用户记录的下一条记录就是最大记录.<br><img src="https://199794.oss-cn-shanghai.aliyuncs.com/blog//snipaste_20201230_230910_1609340961966.png" alt="snipaste_20201230_230910.png"><br>当我们把第2条记录删除:<br><img src="https://199794.oss-cn-shanghai.aliyuncs.com/blog//snipaste_20201230_232233_1609341761316.png" alt="snipaste_20201230_232233.png"><br>删除第二条记录后我们可以发现这些变化:  </p><ul><li>第二条记录并没有从存储空间移除,而是把该条记录的delete_mask值设置为1</li><li>第二条记录的next_record值变成0,表示该记录没有下一条记录</li><li>第一条记录的next_record指向了第三条记录</li><li>最大记录的n_owned值变成了4  </li></ul><h4 id="Page-Directory-页目录"><a href="#Page-Directory-页目录" class="headerlink" title="Page Directory(页目录)"></a>Page Directory(页目录)</h4><p>普通的一条查询语句,最笨的方法是从最小记录开始,沿着链表一直往后找,但是mysql设计者想到了更好的办法,从目录中得到如下方式:  </p><ol><li>将所有正常的记录(包括最大记录和最小记录)划分为几个组</li><li>每个组的最后一条记录的头信息中的n_owned属性表示该组拥有多少条记录</li><li>将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到Page Directory,也就是页目录,页目录中的这些地址偏移量被称为槽点(slot),所以这个页面目录就是由槽组成的.  </li></ol><p><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-02-24_22-44-00_1614177884019.png" alt="Snipaste_20210224_224400.png">  </p><p><strong>对于最小记录所在的分组只能有1条记录,最大记录所在的分组拥有的记录条数只能在1~8条之间,剩下的分组中记录的条数在4-8条之间,所以分组是按照下边的步骤进行的</strong>:  </p><ol><li>初始情况下一个数据页里只有最小记录和最大记录两条,属于两个分组</li><li>之后每插入一条数据,都会从页目录中找到主键值比本记录值大并且差值最小的槽,然后把该槽对应的记录的n_owned值加1,直到组内有8条数据</li><li>在一个组的记录等于8时,再插入一条数据时,会将组拆分为两个组,一个组中4条记录,另一个5条记录,并在页目录中新增一个槽来记录这个新增分组的最大记录偏移量.  </li></ol><p>所以在一个数据页中查找指定主键值的记录的过程分为两步:</p><ol><li>通过二分法确定该记录所在的槽,并找到该槽中主键值最小的那条记录 </li><li>通过记录的next_record属性遍历该槽所在的组中的各个记录 </li></ol><h3 id="页面头部"><a href="#页面头部" class="headerlink" title="页面头部"></a>页面头部</h3><p>为了能得到一个数据页中存储的记录的状态信息,比如本页中已经存储了多少记录,第一条记录的地址是什么,页目录中存储了多少个槽等等.这些信息存储在Page Header部分.</p><h3 id="文件部分"><a href="#文件部分" class="headerlink" title="文件部分"></a>文件部分</h3><p>File Header 主要记录了页的一些通用信息,比如这个页的编号是多少,它上一个页,下一个页是多少等等</p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis慢查询与事务</title>
    <link href="/2021/10/24/Redis%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%B8%8E%E4%BA%8B%E5%8A%A1/"/>
    <url>/2021/10/24/Redis%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%B8%8E%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h3><p>我们知道,redis执行命令有4个步骤:</p><ol><li>发送命令</li><li>命令排队</li><li>执行命令</li><li>返回结果</li></ol><p>慢查询只统计步骤3的时间<br>对于慢查询功能，需要明确两件事：</p><ul><li>预设阀值怎么设置？</li><li>慢查询记录存放在哪？</li></ul><p>Redis提供了slowlog-log-slower-than和slowlog-max-len配置来解决这两个<br>问题。从字面意思就可以看出，slowlog-log-slower-than就是那个预设阀值,它的单位是微秒（1秒=1000毫秒=1000000微秒），默认值是10000，假如执行了一条“很慢”的命令（例如keys*），如果它的执行时间超过了10000微秒，那么它将被记录在慢查询日志中。 </p><p>从字面意思看，slowlog-max-len只是说明了慢查询日志最多存储多少条，并没有说明存放在哪里？实际上Redis使用了一个列表来存储慢查询日志，slowlog-max-len就是列表的最大长度。一个新的命令满足慢查询条件时被插入到这个列表中，当慢查询日志列表已处于其最大长度时，最早插入的一个命令将从列表中移出，例如slowlog-max-len设置为5，当有第6条慢查询插入的话，那么队头的第一条数据就出列，第6条慢查询就会入列。</p><p>虽然慢查询日志是存放在Redis内存列表中的，但是Redis并没有暴露这个列表的键，而是通过一组命令来实现对慢查询日志的访问和管理。  </p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务表示一组动作，要么全部执行，要么全部不执行。例如在社交网站上用户A关注了用户B，那么需要在用户A的关注表中加入用户B，并且在用户B的粉丝表中添加用户A，这两个行为要么全部执行，要么全部不执行，否则会出现数据不一致的情况。<br>Redis提供了简单的事务功能，将一组需要一起执行的命令放到multi和exec两个命令之间。multi命令代表事务开始，exec命令代表事务结束，它们之间的命令是原子顺序执行的</p><p>例如下面操作实现了上述用户关注问题</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; multi<br>OK<br><span class="hljs-number">127.0.0.1:6379</span>&gt; sadd user:a:follow user:b<br>QUEUED<br><span class="hljs-number">127.0.0.1:6379</span>&gt; sadd user:b:fans user:a<br>QUEUED<br></code></pre></td></tr></table></figure><p>Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p><h4 id="Redis事务没有隔离级别的概念"><a href="#Redis事务没有隔离级别的概念" class="headerlink" title="Redis事务没有隔离级别的概念:"></a>Redis事务没有隔离级别的概念:</h4><p>批量操作在发送EXEC命令前被放入到队列缓存,并不会被实际执行,也就不存在事务内的查询要看到事务内的更新,事务外查询不能看到.  </p><h4 id="Redis不保证原子性"><a href="#Redis不保证原子性" class="headerlink" title="Redis不保证原子性:"></a>Redis不保证原子性:</h4><p>Redis中,单条命令是原子性执行的,但事务不保证原子性,且没有回滚,事务中任意命令执行失败,其余的命令仍会被执行.</p><h4 id="事务的三个阶段"><a href="#事务的三个阶段" class="headerlink" title="事务的三个阶段"></a>事务的三个阶段</h4><ul><li>开始事务</li><li>命令入队</li><li>执行事务</li></ul><p>Redis事务相关命令:<br>watch key1 key2…:监视一个或多个key,被监视的key被其他命令改动,则事务被打断</p><p>Redis使用WATCH命令来决定事务是继续执行还是回滚，那就需要在MULTI之前使用WATCH来监控某些键值对，然后使用MULTI命令来开启事务，执行对数据结构操作的各种命令，此时这些命令入队列。</p><p>当使用EXEC执行事务时，首先会比对WATCH所监控的键值对，如果没发生改变，它会执行事务队列中的命令，提交事务；如果发生变化，将不会执行事务中的任何命令，同时事务回滚。当然无论是否回滚，Redis都会取消执行事务前的WATCH命令。<br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-03-01_21-41-09_1614606087741.png" alt="Snipaste_20210301_214109.png"></p><h4 id="若在事务队列中存在命令性错误（类似于java编译性错误），则执行EXEC命令时，所有命令都不会执行"><a href="#若在事务队列中存在命令性错误（类似于java编译性错误），则执行EXEC命令时，所有命令都不会执行" class="headerlink" title="若在事务队列中存在命令性错误（类似于java编译性错误），则执行EXEC命令时，所有命令都不会执行"></a>若在事务队列中存在命令性错误（类似于java编译性错误），则执行EXEC命令时，所有命令都不会执行</h4><p><img src="http://oss.xiaokoua.cn/blog//1659331-20190416205137740-1887538258_1614606203528.png" alt="1659331201904162051377401887538258.png">  </p><h4 id="若在事务队列中存在语法性错误（类似于java的1-0的运行时异常），则执行EXEC命令时，其他正确命令会被执行，错误命令抛出异常。"><a href="#若在事务队列中存在语法性错误（类似于java的1-0的运行时异常），则执行EXEC命令时，其他正确命令会被执行，错误命令抛出异常。" class="headerlink" title="若在事务队列中存在语法性错误（类似于java的1/0的运行时异常），则执行EXEC命令时，其他正确命令会被执行，错误命令抛出异常。"></a>若在事务队列中存在语法性错误（类似于java的1/0的运行时异常），则执行EXEC命令时，其他正确命令会被执行，错误命令抛出异常。</h4><p><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-03-01_21-44-01_1614606257014.png" alt="Snipaste_20210301_214401.png">  </p><p> 使用watch检测balance，在开启事务后（标注1处），在新窗口执行标注2中的操作，更改balance的值，模拟其他客户端在事务执行期间更改watch监控的数据，然后再执行标注1后命令，执行EXEC后，事务未成功执行。<br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-03-01_21-46-05_1614606382969.png" alt="Snipaste_20210301_214605.png"></p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL执行计划</title>
    <link href="/2021/10/24/SQL%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/"/>
    <url>/2021/10/24/SQL%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h3 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h3><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>执行上面sql语句,将得到下面执行计划:<br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-03-10_17-06-16_1615367395708.png" alt="Snipaste_20210310_170616.png">  </p><p>解释一下每个字段的意思:  </p><ul><li>id  在一个大的查询语句中每个 SELECT 关键字都对应一个唯一的 id</li><li>select_typ SELECT 关键字对应的那个查询的类型</li><li>table 表名 </li><li>partitions 匹配的分区信息</li><li>possible_keys 可能用到的索引</li><li>key 实际上使用的索引</li><li>key_len 实际使用到的索引长度</li><li>ref  当使用索引列等值查询时，与索引列进行等值匹配的对象信息</li><li>rows 预估的需要读取的记录条数</li><li>filtered 某个表经过搜索条件过滤后剩余记录条数的百分比</li><li>Extra 一些额外的信息 </li></ul><p>我们看一下连接查询</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">explain</span> select * FROM test<span class="hljs-number">1</span> t<span class="hljs-number">1</span> INNER JOIN test<span class="hljs-number">2</span> t<span class="hljs-number">2</span> <span class="hljs-literal">on</span> t<span class="hljs-number">1</span>.guid=t<span class="hljs-number">2</span>.guid<br></code></pre></td></tr></table></figure><p><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-03-10_17-21-17_1615368088190.png" alt="Snipaste_20210310_172117.png">  </p><h5 id="id"><a href="#id" class="headerlink" title="id"></a>id</h5><p>查询语句中每出现一个 SELECT 关键字，MySQL就会为它分配一个唯一的 id值。<br>对于连接查询来说，一个 SELECT 关键字后边的 FROM 子句中可以跟随多个表，所以在连接查询的执行计划中，每个表都会对应一条记录，但是这些记录的id值都是相同的.出现在前边的表表示驱动表，出现在后边的表表示被驱动表  </p><p>对于包含 UNION 子句的查询语句来说，每个 SELECT 关键字对应一个 id 值也是没错的，不过还是有点儿特别的:  </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table s1 <span class="hljs-keyword">WHERE</span> s1.key1 = <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table s2 <span class="hljs-keyword">WHERE</span> s2.key1 = <span class="hljs-string">&#x27;a&#x27;</span><br></code></pre></td></tr></table></figure><p><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-03-10_18-00-11_1615370425433.png" alt="Snipaste_20210310_180011.png"></p><p>UNION字句会把多个查询的结果集合并起来并对结果集中的记录进行去重,怎么去重? 它使用的是内部临时表,正如上边的查询计划中表示,UNION字句是为了把id为1的查询和id为2的查询结果集合并起来并去重,所以在内部创建了一个名为&lt;union1,2&gt;的临时表,跟 UNION 对比起来， UNION ALL 就不需要为最终的结果集进行去重，它只是单纯的把多个查询的结果集中的记录合并成一个并返回给用户，所以也就不需要使用临时表。所以在包含 UNION ALL 子句的查询的执行计划中，就没有那个 id 为 NULL 的记录  </p><h5 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h5><ul><li><p>simple 查询语句中不包含UNION或者子查询的都算做SIMPLE类型,比如单表查询和连接查询.  </p></li><li><p>primary 对于包含UNION,UNION ALL 或者子查询的大查询来说,它是由几个小查询组成的,其中最左边的那个查询的select_type 值就是primary,比方说:  </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table s1 <span class="hljs-keyword">WHERE</span> s1.key1 = <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table s2 <span class="hljs-keyword">WHERE</span> s2.key1 = <span class="hljs-string">&#x27;a&#x27;</span><br></code></pre></td></tr></table></figure><p><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-03-10_21-19-07_1615382364591.png" alt="Snipaste_20210310_211907.png">  </p></li><li><p>union 对于包含 UNION 或者 UNION ALL 的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询以外，其余的小查询的 select_type 值就是 UNION,临时表就是<strong>UNION RESULT</strong> </p></li><li><p>SUBQUERY 如果包含子查询的查询语句不能转为对应的emi-join的形式,并且该子查询是不相关子查询,并且查询优化器决定采用将该子查询物化的方式来执行该子查询时,该子查询的第一个select关键字代表的那个查询的select_type就是SUBQUERY,比如下面的查询:  </p></li><li><p>DEPENDENT SUBQUERY  如果包含子查询的查询语句不能够转为对应的 semi-join 的形式，并且该子查询是相关子查询，则该子查询的第一个 SELECT 关键字代表的那个查询的 select_type 就是 DEPENDENT SUBQUERY,<strong>select_type为DEPENDENT SUBQUERY的查询可能会被执行多次</strong></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">EXPLAIN SELECT<br>* <br>FROM<br>single_table <span class="hljs-built_in">s1</span> <br>WHERE<br><span class="hljs-built_in">s1</span>.key1 IN ( SELECT <span class="hljs-built_in">s2</span>.key1 FROM single_table <span class="hljs-built_in">s2</span> WHERE <span class="hljs-built_in">s1</span>.key2 = <span class="hljs-built_in">s2</span>.key2 ) <br><span class="hljs-keyword">OR </span><span class="hljs-built_in">s1</span>.key3 = <span class="hljs-string">&#x27;a&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>DEPENDENT UNION </p></li></ul>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL 表访问方式揭秘</title>
    <link href="/2021/10/24/SQL-%E8%A1%A8%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F%E6%8F%AD%E7%A7%98/"/>
    <url>/2021/10/24/SQL-%E8%A1%A8%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F%E6%8F%AD%E7%A7%98/</url>
    
    <content type="html"><![CDATA[<h2 id="单表访问方法"><a href="#单表访问方法" class="headerlink" title="单表访问方法"></a>单表访问方法</h2><p>对于单表查询来说,查询的执行方式大致分为以下两种: </p><ul><li>使用全表扫描进行查询</li><li>使用索引进行查询  </li></ul><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>我们可以直接通过主键列来定位一条记录,比如我们创建一个案例: </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">table</span> (<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>key1 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>key2 <span class="hljs-type">INT</span>,<br>key3 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>key_part1 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>key_part2 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>key_part3 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>common_field <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br><span class="hljs-keyword">PRIMARY</span> KEY (id),<br>KEY idx_key1 (key1),<br><span class="hljs-keyword">UNIQUE</span> KEY idx_key2 (key2),<br>KEY idx_key3 (key3),<br>KEY idx_key_part(key_part1, key_part2, key_part3)<br>) Engine<span class="hljs-operator">=</span>InnoDB CHARSET<span class="hljs-operator">=</span>utf8;<br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">1438</span>;<br></code></pre></td></tr></table></figure><p><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-05-20_22-07-28_1621519662111.png" alt="Snipaste_20210520_220728.png">  </p><h3 id="ref访问方式"><a href="#ref访问方式" class="headerlink" title="ref访问方式"></a>ref访问方式</h3><p>看看使用二级索引并回表方式的查询步骤:  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> k2=<span class="hljs-number">3841</span><br></code></pre></td></tr></table></figure><p><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-05-20_22-10-32_1621519842586.png" alt="Snipaste_20210520_221032.png">  </p><p>注意以下几个情况:  </p><ul><li>无论普通二级索引还是唯一二级索引,它们的索引列对包含null值得数量并不限制,所以我们采用 key is null 这种形式的搜索条件最多只能使用ref的访问方法而不是const的访问方法.  </li><li>对于包含多个索引列的二级索引来说,只要是最左边连续的索引列与常数的等值比较就可能采用ref的访问方法:  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> key_part1=<span class="hljs-string">&#x27;god like&#x27;</span> <span class="hljs-keyword">and</span> key_part12=<span class="hljs-string">&#x27;legendary&#x27;</span> <span class="hljs-keyword">and</span> key_part3=<span class="hljs-string">&#x27;pent&#x27;</span><br></code></pre></td></tr></table></figure>但是如果最左边的连续索引列并不全是等值比较的话,它的访问方法就不能称为ref了,比如:  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> key_part1=<span class="hljs-string">&#x27;god like&#x27;</span> <span class="hljs-keyword">and</span> key_part2&gt; <span class="hljs-string">&#x27;leng&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="ref-or-null"><a href="#ref-or-null" class="headerlink" title="ref_or_null"></a>ref_or_null</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> *  <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> key1=<span class="hljs-string">&#x27;abc&#x27;</span> <span class="hljs-keyword">or</span> key1 <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span> <br></code></pre></td></tr></table></figure><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-05-20_22-25-16_1621520726788.png" alt="Snipaste_20210520_222516.png">  </li></ul><h3 id="range"><a href="#range" class="headerlink" title="range"></a>range</h3><p>range 就是对于某个key 进行范围查询,略.. </p><h3 id="index"><a href="#index" class="headerlink" title="index"></a>index</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> key_part1,key_part2,key_part3 <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> key_part2=<span class="hljs-string">&#x27;abc&#x27;</span> <br></code></pre></td></tr></table></figure><p>由于 key_part2 并不是联合索引idx_key_part最左边索引列,所以我们无法使用ref或者range访问方法来执行这个语句,但是这个语句刚好是覆盖索引,而且key_part2 也在此索引中,也就是说我们可以通过遍历idex_key_part索引的叶子节点的记录来比较key_part2=’abc’ 这个条件是否成立,把成功匹配的假如结果集,这种采用遍历二级索引记录的执行方式称为index.  </p><h3 id="all"><a href="#all" class="headerlink" title="all"></a>all</h3><p>全表扫描,就是直接扫描聚簇索引  </p><h3 id="有的搜索条件无法使用索引的情况"><a href="#有的搜索条件无法使用索引的情况" class="headerlink" title="有的搜索条件无法使用索引的情况"></a>有的搜索条件无法使用索引的情况</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> key2 &gt; <span class="hljs-number">100</span> <span class="hljs-keyword">OR</span> common_field = <span class="hljs-string">&#x27;abc&#x27;</span>;<br>```  <br>我们把使用不到 idx_key2 索引的搜索条件替换为 <span class="hljs-keyword">TRUE</span><br></code></pre></td></tr></table></figure><p>SELECT * FROM single_table WHERE key2 &gt; 100 OR TRUE</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">接着简化  <br></code></pre></td></tr></table></figure><p>SELECT * FROM single_table WHERE TRUE;</p><pre><code>也就是说一个使用到索引的搜索条件和没有使用该索引的搜索条件使用or连接起来后是无法使用该索引的.  ### 索引合并  使用到多个索引来完成一次查询的执行方法称之为： index merge   #### Intersection合并mysql在特定的情况下才可能会使用到Intersection索引合并:  - 情况一: 二级索引是等值匹配的情况,对于联合索引来说,在联合索引中的每个列都必须等值匹配,不能出现只出现匹配部分列的情况.  - 情况二:主键可以是范围查询,二级索引必须是等值匹配,因为只有在这种情况下根据二级索引查询出的结果集是按照主键值排序的.  #### union合并  - 情况一: 二级索引是等值匹配的情况,对于联合索引来说,在联合索引中的每个列都必须等值匹配,不能出现只匹配部分列的情况  - 情况二:主键列可以是范围匹配 - 情况三: 使用 Intersevtion索引合并的搜索条件  </code></pre>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Buffer Pool</title>
    <link href="/2021/10/24/Buffer-Pool/"/>
    <url>/2021/10/24/Buffer-Pool/</url>
    
    <content type="html"><![CDATA[<h2 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h2><p>如何调节磁盘与CPU的矛盾? 数据存放在表空间的页中,是存储在磁盘上,但是磁盘的速度很慢,所以数据库在处理数据时会把数据加载到内存中,当需要访问某个页的数据时,就会把完整的页全部加载到内存中,也就是说即使我们只需要访问一个页的一条记录,那也需要先把完整的页数据加载到内存中.  在进行完读写访问之后并不着急把该页对应的内存空间释放掉,而是将其缓存起来,这样将来再有请求访问该页面时,就可以省去IO开销  </p><p>为了管理这些页,mysql为他们建立了控制信息块,每个缓存页对应的控制信息占用的内存大小是相同的,把控制信息占用的内存称为控制块,控制块和缓存页是一一对应的,他们都被放到Buffer pool中<br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-05-22_09-19-47_1621646402945.png" alt="Snipaste_20210522_091947.png">    </p><p>启动mysql的时候,会对buffer pool启动初始化操作,随着程序运行,会有数据页缓存到buffer pool上,<br>为了记录buffer Pool中哪些页是可用的,把所有空闲的缓存页对应的控制块作为一个节点放到一个链表中,<br>这个链表称为free链表<br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-05-22_18-06-49_1621678031553.png" alt="Snipaste_20210522_180649.png">  </p><p>有了这个free链表之后就好办事了,每当需要从磁盘加载一个页到Buffer Pool中时,就从free链表中取一个空闲的缓存页,并且把该缓存页对应的控制块信息填上,然后把该缓存页对应的free链表节点从链表中移除,表示该缓存页已经被使用了.  </p><h3 id="flush链表管理"><a href="#flush链表管理" class="headerlink" title="flush链表管理"></a>flush链表管理</h3><p>如果我们修改了Buffer Pool中某个缓存页的数据,那么就和磁盘页不一致了,但是并不会马上刷新到硬盘上,那么如何管理这些刷新的<strong>脏页</strong>,mysql做出如下措施:凡是修改过的缓存页的控制块都加入到一个叫flush链表的结构中,假设某个时间点Buffer Pool中脏页的数量为n,那么对应的flush链表长这样:  </p><p><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-05-22_22-27-23_1621694161782.png" alt="Snipaste_20210522_222723.png">   </p><h3 id="LRU链表"><a href="#LRU链表" class="headerlink" title="LRU链表"></a>LRU链表</h3><p>当Buffer Pool中不再有空闲的缓存页,需要淘汰最近很少使用的缓存页,为了按照最近最少使用的原则区淘汰缓存页的,所以这个链表可以被称为LRU链表,当我们需要访问某个页时:  </p><ul><li>如果该页不在Buffer Pool中,在把该页从磁盘加载到Buffer Pool中的缓存页时,就把该缓存页对应的控制块作为节点塞到链表头部  </li><li>如果该页已经缓存在Buffer Pool中,则直接把该页对应的控制块移动到LRU链表头部    </li></ul><p>也就是说:<strong>只要我们使用到某个缓存页,就把该缓存页调整到LRU链表的头部,这样LRU链表尾部就是最近最少使用的缓存页</strong>  </p><h3 id="划分区域的预读"><a href="#划分区域的预读" class="headerlink" title="划分区域的预读"></a>划分区域的预读</h3><p>  由于mysql存在预读机制:  </p><ul><li>线性预读: 异步读取下一个区的页到Buffer pool </li><li>随机预读: 如果Buffer Pool中已经缓存了某个区的13个连续页面,就会触发异步读取本区中所有的页面到Buffer Pool的请求   </li></ul><p>为了防止使用频率偏低的页面缓存到Buffer Pool中把使用频率非常高的页从Buffer Pool中淘汰掉  </p><p>因为这种情况的存在,所以LRU链表按照一定比例分成两截:  </p><ul><li>热数据区,或称为young区域  </li><li>冷数据区,称为old区域  </li></ul>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库事务</title>
    <link href="/2021/10/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/"/>
    <url>/2021/10/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务?"></a>什么是事务?</h2><p>事务是逻辑上的一组操作,要么都执行,要么都不执行  </p><p>比如现实中的转账业务,一个加钱,一个减钱,必须都成功 </p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>要么全都做,要么全不做的规则称之为原子性  </p><h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>现实世界中的两次状态转换应该是互不影响的，比如说狗哥向猫爷同时进行的两次金额为5元的转账（假设可以在两个ATM机上同时操作）。那么最后狗哥的账户里肯定会少10元，猫爷的账户里肯定多了10元。但是到对应的数据库世界中，事情又变的复杂了一些。  </p><ul><li>读取狗哥账户的余额到变量A中，这一步骤简写为 read(A)   </li><li>将狗哥账户的余额减去转账金额，这一步骤简写为 A = A - 5 </li><li>将狗哥账户修改过的余额写到磁盘里，这一步骤简写为 write(A </li><li>读取猫爷账户的余额到变量B，这一步骤简写为 read(B)</li><li>将猫爷账户的余额加上转账金额，这一步骤简写为 B = B + 5</li><li>将猫爷账户修改过的余额写到磁盘里，这一步骤简写为 write(B)</li></ul><p>我们将狗哥向猫爷同时进行的两次转账操作分别称为 T1 和 T2 ，在现实世界中 T1 和 T2 是应该没有关系的，可以先执行完 T1 ，再执行 T2 ，或者先执行完 T2 ，再执行 T1 ，对应的数据库操作就像这样<br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-05-23_11-24-14_1621740267013.png" alt="Snipaste_20210523_112414.png"><br>真实的数据库中 T1 和 T2 的操作可能交替执行<br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-05-23_11-25-11_1621740327638.png" alt="Snipaste_20210523_112511.png"><br>所以隔离性为并发访问数据库时,一个用户的事务不会被其他事务所干扰,各并发事务之间数据库是独立的  </p><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>比如转账业务,每完成一笔交易后,都需要保证整个系统的余额不变,无论事务是否成功,转账者和收款人的总额不变  </p><h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><p>一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。  </p><h3 id="事务的状态"><a href="#事务的状态" class="headerlink" title="事务的状态"></a>事务的状态</h3><p>根据事务执行的不同阶段,事务大致上划分成了几个状态:  </p><ul><li> <strong>活动的(active)</strong>  事务对应的数据库操作正在执行过程中时,我们就说该事务处在活动的状态  </li><li><strong>部分提交的(partially commited)</strong> 当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并没有刷新到磁盘时，我们就说该事务处在 部分提交的 状态。  </li><li><strong>失败的（failed)</strong> 当事务处在 活动的 或者 部分提交的 状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在 失败的 状态.  </li><li><strong>中止的（aborted)</strong> 如果事务执行了半截而变为 失败的 状态，比如我们前边唠叨的狗哥向猫爷转账的事务，当狗哥账户的钱被<br>扣除，但是猫爷账户的钱没有增加时遇到了错误，从而当前事务处在了 失败的 状态，那么就需要把已经修改的狗哥账户余额调整为未转账之前的金额，换句话说，就是要撤销失败事务对当前数据库造成的影响。书面一点的话，我们把这个撤销的过程称之为 回滚 。当 回滚 操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了 中止的 状态。  </li><li><strong>提交的（committed）</strong> 当一个处在 部分提交的 状态的事务将修改过的数据都同步到磁盘上之后，我们就可以说该事务处在了 提交的 状态。  </li></ul><p><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-05-23_11-48-45_1621741735441.png" alt="Snipaste_20210523_114845.png"></p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Netty入门</title>
    <link href="/2021/10/24/Netty%E5%85%A5%E9%97%A8/"/>
    <url>/2021/10/24/Netty%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><p>同步与异步关注的是消息通信机制,同步就是在发出一个调用时,在没有得到结果之前,该调用就不返回,但是一旦调用返回,就得到返回值了<br>而异步相反,调用在发出之后,这个调用就立即返回了,所以没有返回结果,当一个异步过程调用发出之后,调用者不会立即得到结果,而是在调用发出之后,被调用者通过状态,通知来通知调用者,或者通过回调函数来处理这个调用  </p><h2 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h2><p>阻塞与非阻塞关注的是程序在等待调用结果时的状态<br>阻塞调用是指调用结果返回之前,当前线程会被挂起,调用线程只有在得到结果之后才会返回.<br>非阻塞调用指的是不能立即得到结果之前,该调用不会阻塞当前线程.  </p><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-05-23_23-31-12_1621783890886.png" alt="Snipaste_20210523_233112.png">  </p><h3 id="事件和Channel"><a href="#事件和Channel" class="headerlink" title="事件和Channel"></a>事件和Channel</h3><p>Netty的时间按照入站或出站数据流的相关性进行分类,可能由入站数据或者相关的状态更改而触发的事件包括:  </p><ul><li>连接已被激活或者连接失活;</li><li>数据读取</li><li>用户事件</li><li>错误事件</li></ul><p>出站事件是未来将会触发的某个操作结果: </p><ul><li>打开或者关闭到远程借点的链接</li><li>将数据冲刷到套接字</li></ul><p>Netty的事件可以分发给ChannelHandler处理:<br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-06-14_11-32-32_1623643897654.png" alt="Snipaste_20210614_113232.png">  </p><h3 id="选择器-事件和EventLoop"><a href="#选择器-事件和EventLoop" class="headerlink" title="选择器,事件和EventLoop"></a>选择器,事件和EventLoop</h3><p>在内部,Netty将会为每个Channel分配一个EventLoop,用以处理所有事件,包括: </p><ul><li>注册感兴趣的事件</li><li>将事件派发给ChannelHandler</li><li>安排进一步的动作</li></ul><h3 id="ChannelPipeline接口"><a href="#ChannelPipeline接口" class="headerlink" title="ChannelPipeline接口"></a>ChannelPipeline接口</h3><p>ChannelPipline提供了ChannelHandler链的容器,当Channel被创建时,它会被自动的分配到它专属的ChannelPipeline. Channelhandler安装到ChannelPipeline中的过程如下:  </p><ul><li>一个ChannelInitializer的实现被注册到了ServerBootstrap中;</li><li>当ChannelInitiazer.initChannel()方法被调用时,ChannelInitializer将在ChannelPipeline中安装一组自定义的ChannelHandler;</li><li>ChannelInitializer将它自己从ChannelPipeline中移除</li></ul>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>## 同步与异步</title>
    <link href="/2021/10/24/%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/"/>
    <url>/2021/10/24/%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SSO</title>
    <link href="/2021/10/24/SSO/"/>
    <url>/2021/10/24/SSO/</url>
    
    <content type="html"><![CDATA[<h2 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h2><p>当用户第一次访问应用系统1的时候,因为还没有登录,会被引导到认证系统进行登录:根据用户提供的登录信息,认证系统进行身份验证,如果通过校验,应该返回给用户一个认证的凭据—ticket;用户再访问别的应用的时候就会将这个ticket带上,作为自己的凭据,应用系统接收到请求之后会把ticket送到认证系统进行校验,检验ticket的合法性,如果通过校验,用户可以在不用再次登录的情况下访问应用系统2等..  </p><p>要实现SSO, 需要以下主要的功能:  </p><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>CAS是central Authentication Service的缩写,中央认证服务,一种独立开放指令协议,是开源的企业级单点登录解决方案.  </p><p>CAS 包括两部分:CAS Server和CAS Client </p><p>CAS Server负责完成对用户的认证工作,会为用户签发两个重要的票据:登录票据(TGT)和服务票据(ST)来实现认证过程,CAS Server需要独立部署.  </p><p>CAS Client 负责处理对客户端受保护资源的访问请求,需要对请求方进行身份认证时,重定向到CAS Server进行认证,准确的说,Client一般会以拦截器实现保护资源,对于访问受保护资源的每个web请求,CAS Client会解析请求是否包含Service Ticket(服务票据)  </p><h4 id="核心票据"><a href="#核心票据" class="headerlink" title="核心票据"></a>核心票据</h4><p>CAS的核心就是Ticket,CAS的主要票据有TGT,ST,PGT,PGTIOU,PT,其中TGT,ST是CAS1.0协议中就有的票据,PGT,PGTIOU,PT是CAS2.0协议中有的票据.  </p><h5 id="TGT"><a href="#TGT" class="headerlink" title="TGT"></a>TGT</h5><p>TGT是CAS为用户签发的登录票据,拥有了TGT,用户就可以证明自己在CAS成功登录过,TGT封装了cookie值以及Cookie值对应的用户信息,用户在CAS认证成功后,生成一个TGT对象,放入自己的缓存,可以是session或Redis,同时CAS生成cookie(其实就是TGT的sessionId) 或者生成一个token给浏览器(token可以跨域),当http再次请求到来时,如果传来有CAS生成cookie,则CAS以此seesionId为key查询缓存中有无TGT,如果有的话,则说明用户之前登录过,如果没有,则用户需要重新登录.  </p><h5 id="TGC"><a href="#TGC" class="headerlink" title="TGC"></a>TGC</h5><p>CAS Server 生成TGT放入自己的缓存中,而TGC就是这个缓存的唯一标识  </p><h5 id="ST"><a href="#ST" class="headerlink" title="ST"></a>ST</h5><p>ST是CAS为用户签发的访问某一服务票据,用户访问service时,用户访问service时,service发现用户没有ST,则要求用户去CAS获取ST,用户向CAS发出获取ST的请求,如果用户的请求包含cookie,则CAS会以此cookie值为key查询缓存中有无TGT,如果存在TGT,则用此TGT签发一个ST,返回给用户.用户凭借ST去访问service,service拿ST去CAS验证,验证通过后,允许用户访问资源.   </p><p>为了保证ST的安全性,ST是基于随机生成的,而且CAS规定ST只能存活一定的时间,而且CAS协议规定ST只能使用一次,无论Service Ticket验证是否成功,CAS Service 都会清楚服务端中的该Ticket,从而可以确保一个Service Ticket不被使用两次 .  </p><p><a href="https://blog.csdn.net/wang379275614/article/details/46337529">https://blog.csdn.net/wang379275614/article/details/46337529</a></p>]]></content>
    
    
    <categories>
      
      <category>SSO</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ArrayList源码</title>
    <link href="/2021/10/24/ArrayList%E6%BA%90%E7%A0%81/"/>
    <url>/2021/10/24/ArrayList%E6%BA%90%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyArrayList</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterable</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CAPACITY = <span class="hljs-number">10</span>;  <span class="hljs-comment">//初始容量</span><br><br>    <span class="hljs-keyword">transient</span> Object[] elementData;<br><br>    <span class="hljs-comment">//空数组实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;<br><br>    <span class="hljs-comment">//默认空数组实例,以了解添加第一个元素时,空间需要扩大多少</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<br><br>    <span class="hljs-comment">//与快速失败机制有关的属性,记录容器大小是否更改</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> modCount = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//虚拟机规定的最大数组大小,超过可能会引发OutOfMemoryError</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="hljs-number">8</span>;<br><br>    <span class="hljs-comment">//数组大小</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyArrayList</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyArrayList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">this</span>.elementData = <span class="hljs-keyword">new</span> Object[initialCapacity];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;容量错误&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;<br>        <span class="hljs-comment">//todo</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>        <span class="hljs-comment">//保证容量</span><br>        ensureCapacityInternal(size + <span class="hljs-number">1</span>);<br>        elementData[size++] = e;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculateCapacity</span><span class="hljs-params">(Object[] elementData, <span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>            <span class="hljs-keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);<br>        &#125;<br>        <span class="hljs-keyword">return</span> minCapacity;<br><br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>        modCount++;<br>        <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>) &#123;<br>            grow(minCapacity);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//扩容核心方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">grow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> oldCapacity = elementData.length;<br>        <span class="hljs-comment">//这边右移一位表示一半,所以扩容为原来的1.5大小</span><br>        <span class="hljs-keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>) &#123;<br>            newCapacity = minCapacity;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>) &#123;<br>            newCapacity = hugeCapacity(minCapacity);<br>        &#125;<br>        <span class="hljs-comment">//复制扩容数组</span><br>        elementData = Arrays.copyOf(elementData, newCapacity);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; index &lt; size; index++) &#123;<br>                <span class="hljs-keyword">if</span> (elementData[index] == <span class="hljs-keyword">null</span>) &#123;<br>                    fastRemove(index);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; index &lt; size; index++) &#123;<br>                <span class="hljs-keyword">if</span> (o.equals(elementData[index])) &#123;<br>                    fastRemove(index);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fastRemove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        modCount++;<br>        <span class="hljs-keyword">int</span> numMoved = size - index - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>) &#123;<br>            System.arraycopy(elementData, index + <span class="hljs-number">1</span>, elementData, index, numMoved);<br>        &#125;<br>        elementData[--size] = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hugeCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapaCity)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (minCapaCity &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OutOfMemoryError();<br>        &#125;<br>        <span class="hljs-keyword">return</span> minCapaCity &gt; MAX_ARRAY_SIZE ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;<br>    &#125;<br><br>    <span class="hljs-comment">//返回迭代器</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//内部迭代器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Itr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>        <span class="hljs-keyword">int</span> curosr;  <span class="hljs-comment">//下一个元素index</span><br>        <span class="hljs-keyword">int</span> lastRet = -<span class="hljs-number">1</span>;  <span class="hljs-comment">//  最后一个元素的index;</span><br><br>        <span class="hljs-keyword">int</span> expectedModCount = modCount;  <span class="hljs-comment">//快速失败机制</span><br><br>        Itr() &#123;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> curosr != size;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>            checkForComodification();<br>            <span class="hljs-keyword">int</span> i = curosr;<br>            <span class="hljs-keyword">if</span> (i &gt;= size) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();<br>            &#125;<br><br>            Object[] elementData = MyArrayList.<span class="hljs-keyword">this</span>.elementData;<br>            <span class="hljs-keyword">if</span> (i &gt;= elementData.length) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();<br>            &#125;<br>            curosr = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span> (E) elementData[lastRet = i];<br><br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (lastRet &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException();<br>            &#125;<br>            checkForComodification();<br>            MyArrayList.<span class="hljs-keyword">this</span>.remove(lastRet);<br>            curosr = lastRet;<br>            lastRet = -<span class="hljs-number">1</span>;<br>            expectedModCount = modCount;<br><br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkForComodification</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (modCount != expectedModCount) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JDK</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HashMap</title>
    <link href="/2021/10/24/HashMap/"/>
    <url>/2021/10/24/HashMap/</url>
    
    <content type="html"><![CDATA[<p>HashMap 实现了Map接口,允许放入key为null的元素,也允许插入value为null的元素,除该类未实现同步外,其余跟hashtable大致相同,跟TreeMap不同,该容器不保证元素顺序,容器可能会对元素重新hash,元素的顺序也会被打散,因此不同时间迭代同一个hashMap的顺序可能会不同. java解决hash冲突的办法是冲突链表方法.  </p><p><img src="http://oss.xiaokoua.cn/blog//HashMap_base_1627094785616.png" alt="HashMap_base.png">  </p><p>有两个参数可以影响HashMap的性能:初始容量(inital capacity)和负载系数(load factor).初始容量指定了初始table的大小,负载系数用来指定自动扩容的临界值.当entry的数量超过capacity*load_factor时,容器将自动扩容并重新hash,对于插入元素较多的场景,将初始容量设大可以减少重新hash的次数.  </p><p>将对象放到HashMap时,需要特点关注Hashcode()和equals()方法,hashCode()方法决定了对象会被放到哪个bucket里,当多个对象的hash值冲突时,equals()方法决定了这些对象是否是”同一个对象”  </p>]]></content>
    
    
    <categories>
      
      <category>JDK</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二进制逻辑运算回顾</title>
    <link href="/2021/10/24/%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E5%9B%9E%E9%A1%BE/"/>
    <url>/2021/10/24/%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E5%9B%9E%E9%A1%BE/</url>
    
    <content type="html"><![CDATA[<p>逻辑变量之间的称为逻辑运算,二进制1和0在逻辑上可以代表”真”与”假”,”是”与”否”<br>计算机的逻辑运算主要包括三种基本运算:逻辑加法(又称”或”运算),逻辑乘法(又称”与”运算)和逻辑否定(又称”非”运算),此外还有”异或”运算.  </p><h3 id="或运算"><a href="#或运算" class="headerlink" title="或运算"></a>或运算</h3><p>逻辑加法通常用符号”+”或符号”∨”来表示,逻辑加法的运算规则如下:<br>0+0=0, 0∨0=0<br>0+1=1, 0∨1=1<br>1+1=1, 1∨1=1<br>1+0=1, 1∨0=1</p><h3 id="与运算"><a href="#与运算" class="headerlink" title="与运算"></a>与运算</h3><p>逻辑乘运算通常用符号”x”或”∧”来表示,逻辑乘法运算规则如下:<br>0x0=0 0∧0=0<br>0x1=0 0∧1=0<br>1x0=0 1∧0=0<br>1x1=1 1∧1=1</p><h3 id="非运算"><a href="#非运算" class="headerlink" title="非运算"></a>非运算</h3><p>逻辑非运算又称逻辑否运算。其运算规则为：<br>0=1 非0等于1<br>1=0 非1等于0</p><h3 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h3><p>异或运算用符号⊕表示,运算规则为:<br>a⊕b=(¬a∧b)∨(a∧¬b)<br>0⊕0=0 0同0异或，结果为0<br>0⊕1=1 0同1异或，结果为1<br>1⊕0=1 1同0异或，结果为1<br>1⊕1=0 1同1异或，结果为0</p><p>即两个逻辑变量相异,输出才为1 ,口诀相同取0,相异取1   </p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis底层数据结构</title>
    <link href="/2021/10/24/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2021/10/24/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h2><p>redis没有使用C语言的字符串表示(以空字符结尾的字符数组),而是构建了一种名为简单字符串(simple dynamic string,SDS)的数据结构,SDS除了在保存字符值外,SDS还被用作缓冲区(buffer):AOF模块中的,以及客户端状态的输入缓冲区.  </p><h3 id="SDS定义"><a href="#SDS定义" class="headerlink" title="SDS定义:"></a>SDS定义:</h3><p><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-08-12_07-25-00_1628724317755.png" alt="Snipaste_20210812_072500.png">  </p><p>因为保存了字符串的长度,所以查询字符串长度(strlen)的时间复杂度是O(1)</p><p>redis设置的free空间可以杜绝缓冲区溢出 ,减少修改字符串时带来的内存重分配次数<br>当SDS的API对一个SDS进行修改,并且需要对SDS进行空间扩展的时候,程序不仅会为SDS分配修改所必须要的空间,还会为SDS分配额外的未使用空间.  </p><h4 id="空间预分配"><a href="#空间预分配" class="headerlink" title="空间预分配"></a>空间预分配</h4><p>在SDS的长度小于1MB的时候,Redis会为SDS分配和len属性同样大小的未使用空间(比如13kb时,分配13kb的未使用空间,那么总长度27kb),当长度大于1MB后,会为SDS分配1MB的为使用空间(比如30MB时,分配1MB,总长度31MB+1kb),<br>当将字符串修改为一个更长的字符串时,如果len长度不够,那么将进行扩容,在第二次修改字符串时,如果检测到字符串的未使用空间够本次修改使用,那么将不需要扩容</p><h4 id="惰性释放"><a href="#惰性释放" class="headerlink" title="惰性释放"></a>惰性释放</h4><p>惰性释放用于优化字符串缩短操作,程序并不立即回收多出来的字节. </p><p>例子:  </p><p><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-08-12_07-25-00_1628726243960.png" alt="Snipaste_20210812_072500.png"><br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-08-12_07-57-52_1628726291375.png" alt="Snipaste_20210812_075752.png"></p><p>惰性释放后,如果修改字符串为更长的字符串,可能可以为redis省去一次预分配的操作,算是一种空间换时间的操作. </p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>redis链表就是一个双向链表  </p><h2 id="字典hash"><a href="#字典hash" class="headerlink" title="字典hash"></a>字典hash</h2><p>redis的hash结构由dictht定义<br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-08-12_07-25-00_1628776000904.png" alt="Snipaste_20210812_072500.png">  </p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictht</span>&#123;</span><br>  dictEntry **table;  <span class="hljs-comment">//哈希表数组</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> size;  <span class="hljs-comment">//哈希表大小 </span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> sizemask; <span class="hljs-comment">//哈希表大小掩码,用于计算索引值,总是等于size-1</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> used;  <span class="hljs-comment">//哈希表已有节点的数量</span><br>&#125;dictht<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span>&#123;</span><br>  <span class="hljs-keyword">void</span> * key <span class="hljs-comment">//键</span><br>  <span class="hljs-class"><span class="hljs-keyword">union</span>&#123;</span>  <span class="hljs-comment">//值</span><br>    <span class="hljs-keyword">void</span> * val;<br>    uint64_tu64;<br>    int64_ts64;<br> &#125;v<br>  <span class="hljs-comment">//指向下一个哈希表节点,形成链表</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> *<span class="hljs-title">next</span>;</span><br>&#125;dictEntry<br></code></pre></td></tr></table></figure><p>key属性保存着键值对中的键,而v属性保存键值对的值,值可以是一个指针,或者是一个uint64_t整数,或者是int64_t整数. </p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> dict&#123;<br>  <span class="hljs-comment">//类型特定函数 </span><br>  dictType *<span class="hljs-keyword">type</span>;<br>  <span class="hljs-comment">//私有数据 </span><br>  <span class="hljs-keyword">void</span> *privdata;<br>  <span class="hljs-comment">//哈希表</span><br>  dictht ht[<span class="hljs-number">2</span>];<br>  <span class="hljs-keyword">int</span> rehashidx;  <span class="hljs-comment">//rehash索引,当rehash不进行时,值为-1;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>type指针指向了保存了一簇用于操作特定类型键值对的函数dictType.  </p><p>ht属性是一个包含两个项的数组,每项都是dictht哈希表,只有在rehash的时候会用到ht[1] ,rhashidx记录了rehash的速度. 如果没有在hash,则值为-1  </p><p><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-08-12_22-06-28_1628777203654.png" alt="Snipaste_20210812_220628.png"></p><p>下面简单说一下rehash:  </p><p>当hash表需要扩容时,会为ht[1]分配内存空间,分配的空间的大小也是2的次幂的大小和java一样(ps:为了减少在rehash时,hash的重新分布计算,提高rehash的速度)<br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-08-12_22-10-50_1628777470397.png" alt="Snipaste_20210812_221050.png"><br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-08-12_22-11-27_1628777501726.png" alt="Snipaste_20210812_221127.png"><br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-08-12_22-12-25_1628777556629.png" alt="Snipaste_20210812_221225.png">  </p><p>redis会利用rehashidx进行,渐进式hash,通过递增该值,反映rehash进度,这样可以不用等待rehash全部完成才能进行接下去的操作.  </p><h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><p>redis利用跳跃表实现zset </p><p>先来解释一下什么是跳跃表  </p><p>对于一个单链表来说,即便表中存储的数据是有序的,如果我们要在其中查找出某个数据,也只能从头到尾遍历链表,这样查找效率会很低,如果我们想要提高查找效率,可以考虑在链表上建立索引,每两个节点提取一个节点到上一级,我们把抽出来的那一级叫做索引.  </p><p><img src="http://oss.xiaokoua.cn/blog//%E4%B8%80%E5%B1%82%E8%B7%B3%E8%B7%83%E8%A1%A8_1628778246574.png" alt="一层跳跃表.png"></p><p>这个时候,如果我们假设要查找节点8,我们可以先在索引层遍历,当遍历到索引层中值为7的节点时,发现下一个节点是9,那么要查找的节点肯定就在这之间,我们下降到连表层就找到了这个节点. 同理,再加一层索引:<br><img src="http://oss.xiaokoua.cn/blog//%E4%BA%8C%E5%B1%82%E8%B7%B3%E8%B7%83%E8%A1%A8_1628778504952.png" alt="二层跳跃表.png"><br>其实这也是利用二分的思想<br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-08-12_22-29-25_1628778684969.png" alt="Snipaste_20210812_222925.png"></p><p>zskiplist结构包含以下属性:<br>header:指向跳跃表的头结点.<br>tail:指向跳跃表的尾节点.<br>level:记录目前跳跃表内,层数最大的那个节点的层数.<br>length:记录跳跃表的长度,就是跳跃表目前包含的节点的数量.  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span>&#123;</span><br>  <span class="hljs-comment">//层</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistLevel</span>&#123;</span><br>     <span class="hljs-comment">//前进指针 </span><br>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">forward</span>;</span><br>     <span class="hljs-comment">//跨度</span><br>     <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> span;<br>  &#125;level[];<br>  <span class="hljs-comment">//后退指针</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskipListNode</span> * <span class="hljs-title">backward</span>;</span><br>  <span class="hljs-comment">//分值</span><br>  <span class="hljs-keyword">double</span> score;  <br>  <span class="hljs-comment">//成员对象 </span><br>  robj *obj;<br>&#125;<br></code></pre></td></tr></table></figure><p>zskiplistNode包含以下属性:<br>level数组:其内部元素指向下一个索引的指针<br>前进指针:指向下一个索引<br>跨度:跨度并不只是和遍历有关,跨度实际上是用来计算排位(rank)的,在查找节点的过程中,将沿途访问过的所有层的跨度累计起来,得到的结果就是目标节点在跳跃表中的排位.<br>后退指针:指向上一个节点</p><p>在同一个跳跃表中,多个节点可以包含相同的分值,但每个节点的成员对象必须是唯一的,跳跃表中的节点按照分值大小进行排序,当分值相同时,节点按照成员对象的大小进行排序.  </p><h2 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h2><h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>redis持久化</title>
    <link href="/2021/10/24/redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <url>/2021/10/24/redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>redis支持RDB和AOF两种持久化机制,持久化功能能有效避免因进程退出造成的数据丢失问题</p><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>RDB持久化是把当前进程数据生成快照保存到硬盘的过程,触发RDB持久化过程分为手动触发和自动触发.  </p><p>有两个命令可以用于生成RDB文件,一个是SAVE,另一个是BGSAVE.<br>SAVE命令会阻塞Redis服务器进程,直到RDB文件创建完毕为止,在服务器阻塞期间,服务器不能处理任何命令请求.  </p><p>和SAVE命令阻塞服务器进程的做法不同,BGSAVE命令会派生出一个子进程,然后由子进程创建RDB文件,父进程处理请求,RDB文件的载入工作是在服务区启动时自动执行的,Redis并没有专门用于载入RDB文件的命令.只要redis在启动时检测到RDB文件的存在,就会自动载入RDB文件.  </p><p>如果服务器开启了AOF持久化功能,那么服务器就会优先使用AOF文件来还原数据库状态.<br>只有在AOF持久化功能处于关闭状态时,服务器才会使用RDB文件来还原数据库状态.  </p><p>自动触发RDB的机制:  </p><ol><li>使用save相关配置,如”save m n”.表示m秒内数据集存在n次修改时,自动触发bgsave.(服务器会维护一个dirty属性保存从上次保存RDB后,redis修改次数,还会维护一个lastsave属性保存上次执行保存的时间,通过这两个属性,redis就可以检测保存条件是否满足,reids默认每100ms检测一次).  </li><li>如果从节点执行全量复制操作,主节点自动执行bgsave生成RDB文件并发送给从节点.</li><li>执行debug reload命令重新加载redis时,也会触发save操作.</li><li>默认情况下执行shutdown时,如果没有开启AOF持久化功能则自动执行bgsave.</li></ol><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>除了RDB持久化功能之外,Redis还提供了AOF持久化功能,与RBD持久化通过保存数据库中的键值对来记录数据库状态不同,AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的.  </p><p>AOF会将所有的写命令追加到缓冲区中,AOF缓冲区根据对应的策略向硬盘做同步操作,随着AOF文件越来越大,需要定期对AOF文件进行重写,达到压缩目的(ps:redis也是fork一个子进程执行AOF文件重写功能,AOF文件重写的原理就是读取内存中的键值对,直接对现存键值对进行记录,这样就可以省去从开始到现状经历的各种写操作).  <img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-08-17_20-42-13_1629204146465.png" alt="Snipaste_20210817_204213.png"><br>为了避免子进程在进行AOF重写时,新的写命令导致AOF重写和内存现状不一致的情况,redis设置了AOF重写缓冲区,在主进程fork子进程进行重写任务的开始,新来的命令不仅会进入AOF缓冲区,而且也会进入AOF重写缓冲区,当子进程完成重写工作后,父进程会通知子进程将AOF重写缓冲区的内容写入到新的AOF文件中,这时新的AOF文件将会和当前内存保持一致.  </p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>synchronized</title>
    <link href="/2021/10/24/synchronized/"/>
    <url>/2021/10/24/synchronized/</url>
    
    <content type="html"><![CDATA[<h1 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h1><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p><strong>所谓原子性就是指一个操作或者多个操作,要么全部执行并且执行的过程不会被任何因素打断,要么就都不执行</strong> </p><p>注意:synchronized和volatile特性的最大区别在于原子性,volatile不具备原子性  </p><h3 id="Synchronized使用"><a href="#Synchronized使用" class="headerlink" title="Synchronized使用"></a>Synchronized使用</h3><p>Synchroniezd可以在静态方法,成员方法,成员对象属性上使用,归根结底它上锁的资源只有两类:一个是对象,一个是类.   </p><h3 id="同步原理"><a href="#同步原理" class="headerlink" title="同步原理"></a>同步原理</h3><p>Synchronized在软件层面依赖JVM实现锁,而Juc.Lock在硬件层面依赖特殊的CPU指令.  </p><p>下面看一个Synchronized例子:  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.paddx.test.concurrent;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Method 1 start&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>查看反编译字节码:  </p><p><img src="http://oss.xiaokoua.cn//Snipaste_2021-09-01_07-45-53.png"></p><p>每个对象都有一个监视器锁,当monitor被占用时就会处于锁定状态,获得锁相当于获得了对象的监视器,线程执行monitorenter指令时尝试获取monitor的所有权,过程如下: </p><ol><li>如果monitor的进入数为0,则该线程进入monitor,然后姜进入数设置为1,该线程即为monitor的所有者</li><li>如果线程已经占有该monitor,只是重新进入,则进入monitor的进入数加1 </li><li>如果其他线程已经占用了monitor</li></ol><h2 id="锁的四种状态"><a href="#锁的四种状态" class="headerlink" title="锁的四种状态"></a>锁的四种状态</h2><p>在 synchronized 最初的实现方式是 “阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态切换需要耗费处理器时间，如果同步代码块中内容过于简单，这种切换的时间可能比用户代码执行的时间还长”，这种方式就是 synchronized实现同步最初的方式，这也是当初开发者诟病的地方，这也是在JDK6以前 synchronized效率低下的原因，JDK6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。</p><p>所以目前锁状态一种有四种，从级别由低到高依次是：无锁、偏向锁，轻量级锁，重量级锁，锁状态只能升级，不能降级</p><h2 id="java对象头"><a href="#java对象头" class="headerlink" title="java对象头"></a>java对象头</h2><p>我们以 Hotspot 虚拟机为例，Hopspot 对象头主要包括两部分数据：Mark Word（标记字段） 和 Klass Pointer（类型指针）</p><p>Mark Word：默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。</p><p>Klass Point：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><p>在上面中我们知道了，synchronized 用的锁是存在Java对象头里的，那么具体是存在对象头哪里呢？答案是：存在锁对象的对象头的Mark Word中，那么MarkWord在对象头中到底长什么样，它到底存储了什么呢？</p><p><img src="https://img-blog.csdnimg.cn/20200606113746579.png"></p><p><img src="http://oss.xiaokoua.cn/blog//20200603161323889_1631542568764.png" alt="20200603161323889.png">  </p><p><strong>无锁</strong>：对象头开辟 25bit 的空间用来存储对象的 hashcode ，4bit 用于存放对象分代年龄，1bit 用来存放是否偏向锁的标识位，2bit 用来存放锁标识位为01</p><p><strong>偏向锁</strong>： 在偏向锁中划分更细，还是开辟 25bit 的空间，其中23bit 用来存放线程ID，2bit 用来存放 Epoch，4bit 存放对象分代年龄，1bit 存放是否偏向锁标识， 0表示无锁，1表示偏向锁，锁的标识位还是01</p><p><strong>轻量级锁</strong>：在轻量级锁中直接开辟 30bit 的空间存放指向栈中锁记录的指针，2bit 存放锁的标志位，其标志位为00</p><p><strong>重量级锁</strong>： 在重量级锁中和轻量级锁一样，30bit 的空间用来存放指向重量级锁的指针，2bit 存放锁的标识位，为11</p><p><strong>GC标记</strong>： 开辟30bit 的内存空间却没有占用，2bit 空间存放锁标志位为11。–</p><h3 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h3><p>Monitor可以理解为一个同步工具或者一种同步机制,通常被描述为一个对象,每一个Java对象就有一把看不见的锁,称为内部锁或者Monitor锁.</p><p>Monitor是线程私有的数据结构,每一个线程都有一个可用monitor record列表,同时还有一个全局的可用列表,每一个被锁住的对象都会和一个monitor关联,同时monitor中有一个Owner字段存放拥有该锁的线程唯一标识,表示该锁被这个线程占用.  </p><h3 id="偏向锁的加锁过程"><a href="#偏向锁的加锁过程" class="headerlink" title="偏向锁的加锁过程:"></a>偏向锁的加锁过程:</h3><ol><li>访问Mark Word中偏向锁的标识是否设置成1,锁标志位是否为01,确认为可偏向状态</li><li>如果为可偏向状态,则判断线程ID是否指向当前线程,如果是,进入步骤5,否则进入步骤3</li><li>如果线程ID并未指向当前线程,则通过CAS操作竞争锁,如果竞争成功,则将MArk Word中线程ID设置为当前线程ID,然后执行5;如果竞争失败,执行4.</li><li>如果CAS获取偏向锁失败,则表示有竞争,当到达全局安全点时获得偏向锁的线程被挂起,偏向锁升级为轻量级锁,然后被阻塞在安全点的线程继续往下执行同步代码</li><li>执行同步代码</li></ol><h3 id="轻量锁的加锁过程"><a href="#轻量锁的加锁过程" class="headerlink" title="轻量锁的加锁过程"></a>轻量锁的加锁过程</h3><p>轻量锁是指当锁是偏向锁的时候,却被另外的线程所访问,此时锁就会升级为轻量锁,其他线程会通过自旋的形式尝试获取锁,线程不会阻塞,从而提高性能.</p><p>轻量锁的获取主要分为两种情况: </p><ol><li>当关闭偏向锁功能时</li><li>由于多个线程竞争导致偏向锁升级为轻量级锁</li></ol><p>一旦有第二个线程加入锁竞争,偏向锁就会升级为轻量级锁,竞争是指多个线程轮流获取锁,运气不好,遇到阻塞的情况.  </p><p>在轻量级锁状态下继续竞争,没有抢到锁的线程将自旋,即不停循环判断锁是否能够被成功获取,获取锁<br>的操作就是通过CAS修改对象头里的标志位,先比较当前锁是否未”释放”,如果是将其修改设置为锁定,然后线程将当前锁的持有者信息修改为自己.</p><p>长时间的自旋操作是非常消耗资源的,一个线程持有锁,其他线程就只能在原地空耗CPU,执行不了任何有效的任务,这种现象叫做忙等. </p><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>忙等是有限度的（有个计数器记录自旋次数，默认允许循环10次，可以通过虚拟机参数更改）。如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为重量级锁（依然是CAS修改锁标志位，但不修改持有锁的线程ID）。当后续线程尝试获取锁时，发现被占用的锁是重量级锁，则直接将自己挂起（而不是忙等），等待将来被唤醒。</p><p>重量级锁是指当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态。</p><p>简言之，就是所有的控制权都交给了操作系统，由操作系统来负责线程间的调度和线程的状态变更。而这样会出现频繁地对线程运行状态的切换，线程的挂起和唤醒，从而消耗大量的系统资</p>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MVCC</title>
    <link href="/2021/10/24/MVCC/"/>
    <url>/2021/10/24/MVCC/</url>
    
    <content type="html"><![CDATA[<h3 id="事务并发执行下遇到的问题"><a href="#事务并发执行下遇到的问题" class="headerlink" title="事务并发执行下遇到的问题"></a>事务并发执行下遇到的问题</h3><ul><li><p>脏写<br>如果一个事务修改了另一个未提交事务修改过的数据,就是发生了<strong>脏写</strong>,<br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-09-28_07-28-25_1632785315057.png" alt="Snipaste_20210928_072825.png"><br>sessionA和sessionB各开始了一个事务,如果sessionB中的事务发生了回滚,那么sessionA中的更新也不复存在,这种现象就是脏写 </p></li><li><p>脏读<br>如果一个事务读到了另一个未提交修改过的数据,那就是发生了脏读<br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-09-28_07-32-39_1632785570717.png" alt="Snipaste_20210928_073239.png"><br>sessionB先修改了number为1的数据,在sessionB还未提交事务的时候,sessionA读取了number为1的数据,得到name为’关羽’,那么sessionA就读取到了sessionB还未提交的脏数据</p></li><li><p>不可重复读</p></li></ul><p>如果一个事务只能读到另一个已经提交的的事务修改过的数据,并且其他事务每对该数据进行一次修改并提交后,该事务都能查询到最新值,那么就是发生了不可重复读  </p><p><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-09-28_07-41-17_1632786087192.png" alt="Snipaste_20210928_074117.png">  </p><p>sessionB提交了几个事务(隐式提交,语句结束事务就提交了),每次提交后,sessionA中的事务都可以查看到最新的值,这种现象称为不可重复读.  </p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>redo日志</title>
    <link href="/2021/10/24/redo%E6%97%A5%E5%BF%97/"/>
    <url>/2021/10/24/redo%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h2 id="redo日志是啥"><a href="#redo日志是啥" class="headerlink" title="redo日志是啥"></a>redo日志是啥</h2><p>在真正访问页面之前,需要把在磁盘上的页缓存到Buffer Pool之后才可以访问,但是在事务的持久性的特性中,对于一个已经提交的事务,在事务提交后即使系统崩溃了,这个事务对数据库所做的更改页不能丢失,但是假如事务提交后发生了某个故障,导致内存中的数据都失效了,那么数据库如何做到持久性?  </p><p>我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效,即使后来系统崩溃,在重启后也能把这种修改恢复出来,所以没必要在事务提交时就把该事务在内存中修改的页刷新到磁盘,只需要把修改了哪些东西记录一下就好,那么事务对数据亏所做的修改又可以被恢复,所以上述内容也被称为重做日志(redo log)  </p><p>redo日志的好处如下:  </p><ul><li>redo日志占用的空间非常小  </li><li>redo日志是顺序写入磁盘,在执行事务的过程中,每执行一条语句,就可能产生若干redo 日志,这些日志是按照顺序产生的顺序写入磁盘的,也就是使用顺序IO  </li></ul><h3 id="redo-日志格式"><a href="#redo-日志格式" class="headerlink" title="redo 日志格式"></a>redo 日志格式</h3><p>redo 日志本质上只是记录了一下事务对数据库做了哪些修改,针对事务对数据库的不同修改场景定义了多种类型的 redo 日志，但是绝大部分类型的 redo 日志都有下边这种通用的结构<br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-05-23_12-16-41_1621743411311.png" alt="Snipaste_20210523_121641.png">  </p><ul><li>type:该条redo日志的类型 </li><li>space ID:表空间ID </li><li>page number: 页号</li><li>data:该条redo日志的具体内容  </li></ul>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>post title</title>
    <link href="/2021/10/24/post-title/"/>
    <url>/2021/10/24/post-title/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/10/24/hello-world/"/>
    <url>/2021/10/24/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
