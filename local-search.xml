<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>test</title>
    <link href="/2022/03/27/test/"/>
    <url>/2022/03/27/test/</url>
    
    <content type="html"><![CDATA[<h1 id="11111"><a href="#11111" class="headerlink" title="11111"></a>11111</h1>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>redis对象</title>
    <link href="/2021/10/31/redis%E5%AF%B9%E8%B1%A1/"/>
    <url>/2021/10/31/redis%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis对象"><a href="#Redis对象" class="headerlink" title="Redis对象"></a>Redis对象</h1><p>我们介绍了redis主要用到的数据结构,比如简单字符串(SDS),双端链表,字典,压缩列表,整数集合等. </p><p>redis并没有直接使用这些数据结构来实现键值对数据库,而是基于这些对象实现了一个对象系统,这个系统包含字符串对象,列表对象,哈希对象,集合对象和有序集合对象等.  </p><p>通过这五种不同类型的对象,Redis可以在执行命令前,根据对象的类型判断一个对象是否可以执行给定的命令,使用对象的另一个好处是,可以针对不同的使用场景,为对象设置不同的底层数据结构实现.  Redis的对象系统还实现了引用计数和内存回收技术.通过引用计数实现了对象共享机制</p><h2 id="对象的类型和编码"><a href="#对象的类型和编码" class="headerlink" title="对象的类型和编码"></a>对象的类型和编码</h2><p>每次创建一个键值对时,至少会创建两个对象,一个对象用作键值对的(键对象)，一个用作键值对的（值对象）</p><p>redis中的每个对象都由一个redisObject结构表示，该结构中和保存数据有关的三个属性分别是type属性，encoding属性和ptr属性</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> redisObject&#123;<br>  <span class="hljs-comment">//类型</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">type</span>;<br>  <span class="hljs-comment">//编码</span><br>  <span class="hljs-keyword">unsigned</span> encoding:<span class="hljs-number">4</span>;<br>  <span class="hljs-comment">//指向底层实现数据结构的指针</span><br>  <span class="hljs-keyword">void</span> *ptr;<br>&#125;<br></code></pre></td></tr></table></figure><p>type属性记录了对象的类型,这个属性表示了redis键值对对象的类型,我们知道,redis键值对的键总是字符串对象而值可以是多种,如下记录了type的各种类型</p><ul><li>REDIS_STRING: 字符串对象    (type命令对应 “string”)</li><li>REDIS_LIST:列表对象               (type命令对应 “list”)</li><li>REDIS_HASH:哈希对象             (type命令对应 “hash”)</li><li>REDIS_SET:集合对象                 (type命令对应 “set”)</li><li>REDIS_ZSET:有序集合对象        (type命令对应 “zset”) </li></ul><h4 id="编码和底层实现"><a href="#编码和底层实现" class="headerlink" title="编码和底层实现"></a>编码和底层实现</h4><p>encoding属性记录了对象所使用的编码,也就是说对象使用了什么数据结构作为对象的底层实现</p><table><thead><tr><th align="center">编码常量</th><th align="center">编码所对应的底层数据结构</th></tr></thead><tbody><tr><td align="center">REDIS_ENCODING_INT</td><td align="center">long类型的整数</td></tr><tr><td align="center">REDIS_ENCODING_EMBSTR</td><td align="center">embstr编码的简单动态字符串</td></tr><tr><td align="center">REDIS_ENCODING_ROW</td><td align="center">简单动态字符串</td></tr><tr><td align="center">REDIS_ENCODING_HT</td><td align="center">字典</td></tr><tr><td align="center">REDIS_ENCODING_LINKEDLIST</td><td align="center">双端链表</td></tr><tr><td align="center">REDIS_ENCODING_ZIPLIST</td><td align="center">压缩列表</td></tr><tr><td align="center">REDIS_ENCODING_INTSET</td><td align="center">整数集合</td></tr><tr><td align="center">REDIS_ENCODING_SKIPLIST</td><td align="center">跳跃表和字典</td></tr></tbody></table><p>每种类型的对象都至少使用了两种类型不同的编码:  </p><table><thead><tr><th align="center">对象</th><th align="center">类型</th><th align="center">底层对象编码</th><th align="center">底层对象</th></tr></thead><tbody><tr><td align="center">字符串对象</td><td align="center">REDIS_STRING</td><td align="center">REDIS_ENCODING_INT</td><td align="center">使用整数值实现的字符串对象</td></tr><tr><td align="center">字符串对象</td><td align="center">REDIS_STRING</td><td align="center">REDIS_ENCODING_EMBSTR</td><td align="center">使用embstr编码的简单动态字符串实现的字符串对象</td></tr><tr><td align="center">字符串对象</td><td align="center">REDIS_STRING</td><td align="center">REDIS_ENCODING_ROW</td><td align="center">使用简单动态字符串实现的字符串对象</td></tr><tr><td align="center">列表对象</td><td align="center">REDIS_LIST</td><td align="center">REDIS_ENCODING_ZIPLIST</td><td align="center">使用压缩列表实现的列表对象</td></tr><tr><td align="center">列表对象</td><td align="center">REDIS_LIST</td><td align="center">REDIS_ENCODING_LINKEDLIST</td><td align="center">使用双端链表实现的列表对象</td></tr><tr><td align="center">哈希对象</td><td align="center">REDIS_HASH</td><td align="center">REDIS_ENCODING_ZIPLIST</td><td align="center">使用压缩列表实现的哈希对象</td></tr><tr><td align="center">哈希对象</td><td align="center">REDIS_HASH</td><td align="center">REDIS_ENCODING_HT</td><td align="center">使用字典实现的哈希对象</td></tr><tr><td align="center">集合对象</td><td align="center">REDIS_SET</td><td align="center">REDIS_ENCODING_INTSET</td><td align="center">使用整数集合实现的集合对象</td></tr><tr><td align="center">集合对象</td><td align="center">REDIS_SET</td><td align="center">REDIS_ENCODING_HT</td><td align="center">使用字典实现的</td></tr><tr><td align="center">有序集合对象</td><td align="center">REDIS_ZSET</td><td align="center">REDIS_ENCODING_ZIPLIST</td><td align="center">使用压缩列表实现的有序集合对象</td></tr><tr><td align="center">有序集合对象</td><td align="center">REDIS_ZSET</td><td align="center">REDIS_ENCODING_SKIPLIST</td><td align="center">使用跳跃表实现的有序集合对象</td></tr></tbody></table><p>使用<strong>OBJECT ENCODING</strong>命令可以查看数据库键值对值对象的底层编码</p><p>通过encoding属性关联对象类型使用的底层编码,极大的提升了Redis的灵活性和效率性</p><h4 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h4><p>如果一个字符串对象保存的是整数值,并且这个整数值可以使用long类型来表示,那么使用REDIS_ENCODING_INT</p><p>如果字符串对象保存的是一个字符串值,并且这个字符串的长度大于32字节,那么使用REDIS_ENCODING_ROW</p><p>如果字符串对象保存的是一个字符串值,并且这个字符串的长度小于32字节,那么使用REDIS_ENCODING_EMBSTR</p><h5 id="编码的转换"><a href="#编码的转换" class="headerlink" title="编码的转换"></a>编码的转换</h5><p>int编码的字符串对象和embstr编码的字符串对象在改变了字符串对象的值以后会将字符串对象编码改为row,因为redis没有为emstr提供修改程序,所以embstr实际上是只读的.</p><h4 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h4><p>列表对象的编码可以是ziplist和linkedlist</p><h5 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h5><p>当列表对象可以同时满足以下两个条件时,列表对象使用ziplist编码</p><ul><li>列表对象保存的所有字符串元素的长度都小于64字节</li><li>列表对象保存的元素数量小于512个,不能满足这两个条件的列表对象需要使用linkedlist编码</li></ul><h4 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h4><p>哈希对象的编码可以是ziplist和hashtable</p><p>ziplist编码的哈希对象使用压缩列表作为底层实现,每当有新的键值对要加入到哈希对象时,reids会将保存了键的压缩列表节点推入到压缩列表表尾,然后将保存了值的压缩列表节点推入到压缩列表表尾,因此:</p><ul><li>保存了同一键值对的两个节点总是紧挨在一起,保存键的节点在前,保存值得节点在后</li><li>先添加的键值对在压缩列表的前头  </li></ul><p>如下图所示  </p><p><img src="http://oss.xiaokoua.cn//Snipaste_2021-10-31_17-53-08.png"></p><h5 id="编码转换-1"><a href="#编码转换-1" class="headerlink" title="编码转换"></a>编码转换</h5><p>当哈希对象可以同时满足以下两个条件时,哈希对象使用ziplist编码</p><ul><li>哈希对象保存所有键值对的键和值的字符串长度都小于64字节</li><li>哈希对象保存的键值对的数量小于512个</li></ul><h4 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h4><p>集合对象的编码可以是intset和hashtable()</p><h5 id="编码转换-2"><a href="#编码转换-2" class="headerlink" title="编码转换"></a>编码转换</h5><p>当集合对象可以同时满足以下两个条件时,对象使用intset编码;  </p><ul><li>集合对象保存的所有元素都是整数值</li><li>集合对象保存的所有元素数量不超过512个</li></ul><h4 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h4><p>有序集合的编码可以是ziplist和skiplist  </p><p>ziplist编码的压缩列表对象使用压缩列表作为底层实现,每个元素使用两个紧挨在一起的压缩列表节点来保存,第一个节点保存元素的成员,第二个节点保存元素的分值 <strong>注意这里利用了压缩列表的有序性</strong></p><p>有序集合对象使用skiplist  和hash结构来实现zset,为什么需要hash结构,因为redis在hash结构中保存了zset的键和分值的映射.使得ZSCORE命令的时间复杂度为O(1)  </p><h5 id="编码转换-3"><a href="#编码转换-3" class="headerlink" title="编码转换"></a>编码转换</h5><p>当有序集合对象可以同时满足以下两个条件时,对象使用ziplist编码</p><ul><li>有序集合保存的元素数量小于128个</li><li>有序集合保存的所有成员的长度都小于64字节 </li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>索引的使用</title>
    <link href="/2021/10/24/%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/10/24/%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="B-树索引适用的条件"><a href="#B-树索引适用的条件" class="headerlink" title="B+树索引适用的条件"></a>B+树索引适用的条件</h3><p>举例说明,我们创建一个表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> person_info(<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> auto_increment,<br>name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>birthday <span class="hljs-type">DATE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>phone_number <span class="hljs-type">CHAR</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>country <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br><span class="hljs-keyword">PRIMARY</span> KEY (id),<br>KEY idx_name_birthday_phone_number (name, birthday, phone_number)<br>);<br></code></pre></td></tr></table></figure><p>可知,这个表会创建两个索引,一个聚簇索引和联合索引,聚簇索引如下图所示:<br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-02-25_13-52-53_1614232385407.png" alt="Snipaste_20210225_135253.png"></p><h4 id="全值匹配"><a href="#全值匹配" class="headerlink" title="全值匹配"></a>全值匹配</h4><p>如果搜索条件中的列和索引列一致的话,这种情况被称为全值匹配,比如说如下查找语句:  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;Ashburn&#x27;</span> <span class="hljs-keyword">AND</span> birthday = <span class="hljs-string">&#x27;1990-09-27&#x27;</span> <span class="hljs-keyword">AND</span> phone_num<br>ber = <span class="hljs-string">&#x27;15123983239&#x27;</span>;<br></code></pre></td></tr></table></figure><p>那么查询过程如下:  </p><ul><li>因为B+树的数据页和记录是先按照name列的值进行排序的,所以可以很快定位到name值是Ashburn的记录位置</li><li>在name列相同的记录里按照birthday值进行排序的,所以在name列的值是Ashburn里又快速定位到birthday是’1990-09-27’的记录,所以联合索引的3个列都可能会用到</li></ul><p>改变搜索条件的位置,对搜索顺序没影响,Mysql有个茶村优化器的东西,会分析搜索条件,并按照可以使用的索引的顺序来决定先使用哪个搜索条件.</p><h4 id="匹配左边的列"><a href="#匹配左边的列" class="headerlink" title="匹配左边的列"></a>匹配左边的列</h4><p>其实搜索也不用包含全部的列,只包含左边就行,比如下面的查询语句:  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;Ashburn&#x27;</span>;<br></code></pre></td></tr></table></figure><p>但是只有右边的搜索条件,就用不到索引,比如下面的搜索语句:  </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> birthday = <span class="hljs-string">&#x27;1990-09-27&#x27;</span>;<br></code></pre></td></tr></table></figure><p>因为name值不同的记录中,birthday可能是无序的,无法使用二分查找,所以如果我们想使用联合索引中尽可能多的列,搜索条件中的各个列必须是联合索引中从最左边连续的列.</p><h4 id="匹配列前缀"><a href="#匹配列前缀" class="headerlink" title="匹配列前缀"></a>匹配列前缀</h4><p>在页中需要对列进行排序,就需要用到列的排序规则,那么一个字符串的排序规则如下:  </p><ol><li>先按照字符串的第一个字符进行排序</li><li>如果第一个字符相同再按照第二个字符进行排序,以此类推</li></ol><p>也就是说这些字符串的前n个字符,前缀都是排好序的,所以对于字符串类型的索引列来说,我们只匹配前缀也是可以快速定位记录的,比如:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;As%&#x27;</span>;<br></code></pre></td></tr></table></figure><h4 id="匹配范围值"><a href="#匹配范围值" class="headerlink" title="匹配范围值"></a>匹配范围值</h4><p>比如下面的查询语句: </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> &gt; <span class="hljs-string">&#x27;Asa&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-type">name</span> &lt; <span class="hljs-string">&#x27;Barlow&#x27;</span>;<br></code></pre></td></tr></table></figure><p>查找过程如下:  </p><ol><li>找到name值为Asa的记录</li><li>找到name值为Barlow的记录</li><li>找到这些记录的主键值,再到聚簇索引中回表查找完整的记录</li></ol><p><strong>如果对多个列同时进行范围查找的话,只有对最左边的那个列进行范围查找的时候才能用到B+树索引</strong>,比如:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> &gt; <span class="hljs-string">&#x27;Asa&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-type">name</span> &lt; <span class="hljs-string">&#x27;Barlow&#x27;</span> <span class="hljs-keyword">AND</span> birthday &gt; <span class="hljs-string">&#x27;1980-01-0</span><br><span class="hljs-string">1&#x27;</span>;<br></code></pre></td></tr></table></figure><p>这个查询中通过name进行范围查找的记录可能并不是按照birthday列进行排序的,所以只能用到name列部分.  </p><h4 id="精确匹配某一列并范围匹配某一列"><a href="#精确匹配某一列并范围匹配某一列" class="headerlink" title="精确匹配某一列并范围匹配某一列"></a>精确匹配某一列并范围匹配某一列</h4><p>如果左边的列是精确查找,则右边的列可以进行范围查找,比如这样:  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;Ashburn&#x27;</span> <span class="hljs-keyword">AND</span> birthday &gt; <span class="hljs-string">&#x27;1980-01-01&#x27;</span> <span class="hljs-keyword">AND</span> birthday<br>&lt; <span class="hljs-string">&#x27;2000-12-31&#x27;</span> <span class="hljs-keyword">AND</span> phone_number &gt; <span class="hljs-string">&#x27;15100000000&#x27;</span>;<br></code></pre></td></tr></table></figure><p>因为name值相同,那么birthday是排序好的,所以birthday还可以用到索引,但是phone_number就不能 </p><h4 id="用于排序"><a href="#用于排序" class="headerlink" title="用于排序"></a>用于排序</h4><p>我们说说不能使用索引排序的情况,比如说这样的:  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-type">name</span>, birthday <span class="hljs-keyword">DESC</span> <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><ul><li>先从索引的最左边确定name列最小的值,然后找到name列等于该值得所有记录,然后从name列等于该值得最右边那条记录开始往左找10条记录</li><li>如果name列等于最小值得记录不足10条,再继续往右找name值第二小的记录,重复上边的过程,直到找到10条记录为止.</li></ul><p>mysql觉得这样不如直接文件排序来的快,所以就直接规定使用联合索引的排序列必须是一致的.  </p><p>要想使用索引进行排序,必须保证索引列是以单独列的形式出现,而不是修饰过的形式,比如:  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> UPPER(<span class="hljs-type">name</span>) <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><h4 id="回表的代价"><a href="#回表的代价" class="headerlink" title="回表的代价"></a>回表的代价</h4><p>因为我们创建的联合索引,没有包含所有的字段,所以在查询所有字段的时候需要一次回表操作,由于联合索引B+树中的记录会按照name列的值进行排序,所以值在Asa~Barlow之间的记录在磁盘中的存储是相连的,集中分布在一个或几个数据页中,可以很快的从磁盘中读出来,这种读取方式可以称为顺序IO,根据从联合索引获取到的主键字段,而这些主键可能不是连续的,所以在聚簇索引中可能需要访问不同的数据页,这种方式可以称为随机IO.<strong>需要回表的记录越多,使用二级索引的性能越低</strong>.<br>实际上查询优化器会帮助我们判断什么时候采用全表扫描,什么时候使用二级索引+回表方式,如果需要回表的记录越少,优化器就会倾向采用二级索引,比如像这样的查询:  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> person_info <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> &gt; <span class="hljs-string">&#x27;Asa&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-type">name</span> &lt; <span class="hljs-string">&#x27;Barlow&#x27;</span> <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><h4 id="如何挑选索引"><a href="#如何挑选索引" class="headerlink" title="如何挑选索引"></a>如何挑选索引</h4><h5 id="只为用于搜索-排序-或者分组的列创建索引"><a href="#只为用于搜索-排序-或者分组的列创建索引" class="headerlink" title="只为用于搜索,排序,或者分组的列创建索引"></a>只为用于搜索,排序,或者分组的列创建索引</h5><p>也就是说,只为出现在where字句中的列,连接字句中的连接列,或者出现在order by或者group by 字句中列创建索引 </p><h5 id="考虑列的基数"><a href="#考虑列的基数" class="headerlink" title="考虑列的基数"></a>考虑列的基数</h5><p>列的基数 指的是某一列中不重复数据的个数，比方说某个列包含值 2, 5, 8, 2, 5, 8, 2, 5, 8 ，虽然有 9 条记录，但该列的基数却是 3 。也就是说，在记录行数一定的情况下，列的基数越大，该列中的值越分散，列的基数越小，该列中的值越集中。这个 列的基数 指标非常重要，直接影响我们是否能有效的利用索引。假设某个列的基数为 1 ，也就是所有记录在该列中的值都一样，那为该列建立索引是没有用的，因为所有值都一样就无法排序，无法进行快速查找了～ 而且如果某个建立了二级索引的列的重复值特别多，那么使用这个二级索引查出的记录还可能要做回表操作，这样性能损耗就更大了。所以结论就是：最好为那些列的基数大的列建立索引，为基数太小列的建立索引效果可能不好。</p><h5 id="索引列的类型尽量小"><a href="#索引列的类型尽量小" class="headerlink" title="索引列的类型尽量小"></a>索引列的类型尽量小</h5><p>我们在定义表结构的时候要显式的指定列的类型，以整数类型为例，有 TINYINT 、 MEDIUMINT 、 INT 、 BIGINT这么几种，它们占用的存储空间依次递增，我们这里所说的 类型大小 指的就是该类型表示的数据范围的大小。能表示的整数范围当然也是依次递增，如果我们想要对某个整数列建立索引的话，在表示的整数范围允许的情况下，尽量让索引列使用较小的类型，比如我们能使用 INT 就不要使用 BIGINT ，能使用 MEDIUMINT 就不要使用INT ～ 这是因为：</p><ul><li>数据类型越小，在查询时进行的比较操作越快 </li><li>数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘 I/O 带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。</li></ul><h5 id="索引字符串的前缀"><a href="#索引字符串的前缀" class="headerlink" title="索引字符串的前缀"></a>索引字符串的前缀</h5><p>我们知道一个字符串其实是由若干个字符组成，如果我们在 MySQL 中使用 utf8 字符集去存储字符串的话，编码一个字符需要占用 1~3 个字节。假设我们的字符串很长，那存储一个字符串就需要占用很大的存储空间。在我们需要为这个字符串列建立索引时，那就意味着在对应的 B+ 树中有这么两个问题：</p><ul><li>B+ 树索引中的记录需要把该列的完整字符串存储起来，而且字符串越长，在索引中占用的存储空间越大。</li><li>如果 B+ 树索引中索引列存储的字符串很长，那在做字符串比较时会占用更多的时间。</li></ul><p>我们前边儿说过索引列的字符串前缀其实也是排好序的，所以索引的设计者提出了个方案 — 只对字符串的前几个字符进行索引也就是说在二级索引的记录中只保留字符串前几个字符。这样在查找记录时虽然不能精确的定位到记录的位置，但是能定位到相应前缀所在的位置，然后根据前缀相同的记录的主键值回表查询完整的字符串值，再对比就好了。这样只在 B+ 树中存储字符串的前几个字符的编码，既节约空间，又减少了字符串的比较时间，还大概能解决排序的问题，何乐而不为，比方说我们在建表语句中只对 name 列的前10个字符进行索引可以<br>这么写：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> person_info(<br>name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>birthday <span class="hljs-type">DATE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>phone_number <span class="hljs-type">CHAR</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>country <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>KEY idx_name_birthday_phone_number (name(<span class="hljs-number">10</span>), birthday, phone_number)<br>);<br></code></pre></td></tr></table></figure><p>name(10) 就表示在建立的 B+ 树索引中只保留记录的前 10 个字符的编码，这种只索引字符串值的前缀的策略是我们非常鼓励的，尤其是在字符串类型能存储的字符比较多的时候。如果使用了索引列前缀，比方说前边只把 name 列的前10个字符放到了二级索引中,如果需要对name值进行排序,就无法使用二级索引了.</p><h5 id="让索引列在比较表达式中单独出现"><a href="#让索引列在比较表达式中单独出现" class="headerlink" title="让索引列在比较表达式中单独出现"></a>让索引列在比较表达式中单独出现</h5><p>假设表中有一个整数列 my_col ，我们为这个列建立了索引。下边的两个 WHERE 子句虽然语义是一致的，但是在效率上却有差别：</p><ol><li>WHERE my_col * 2 &lt; 4</li><li>WHERE my_col &lt; 4/2</li></ol><p>第1个 WHERE 子句中 my_col 列并不是以单独列的形式出现的，而是以 my_col * 2 这样的表达式的形式出现的，存储引擎会依次遍历所有的记录，计算这个表达式的值是不是小于 4 ，所以这种情况下是使用不到为 my_col 列建立的 B+ 树索引的。而第2个 WHERE 子句中 my_col 列并是以单独列的形式出现的，这样的情况可以直接使用B+ 树索引。</p><p>所以结论就是：如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出现的话，是用不到索引的。</p><h5 id="主键插入顺序"><a href="#主键插入顺序" class="headerlink" title="主键插入顺序"></a>主键插入顺序</h5><p>我们知道，对于一个使用 InnoDB 存储引擎的表来说，在我们没有显式的创建索引时，表中的数据实际上都是存储在 聚簇索引 的叶子节点的。而记录又是存储在数据页中的，数据页和记录又是按照记录主键值从小到大的顺序进行排序，所以如果我们插入的记录的主键值是依次增大的话，那我们每插满一个数据页就换到下一个数据页继续插，而如果我们插入的主键值忽大忽小的话，这就比较麻烦了，假设某个数据页存储的记录已经满了，它存储的主键值在 1~100 之间：<br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-02-26_14-30-22_1614321074335.png" alt="Snipaste_20210226_143022.png"></p><p> 如果此时再插入一条主键值为 9 的记录，那它插入的位置就如下图：<br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-02-26_14-31-27_1614321097429.png" alt="Snipaste_20210226_143127.png"><br>可这个数据页已经满了啊，再插进来咋办呢？我们需要把当前页面分裂成两个页面，把本页中的一些记录移动到新创建的这个页中。页面分裂和记录移位意味着什么？意味着：性能损耗！所以如果我们想尽量避免这样无谓的性能损耗，最好让插入的记录的主键值依次递增，这样就不会发生这样的性能损耗了。所以我们建议：让主键具有 AUTO_INCREMENT ，让存储引擎自己为表生成主键，而不是我们手动插入.</p><h5 id="冗余和重复索引"><a href="#冗余和重复索引" class="headerlink" title="冗余和重复索引"></a>冗余和重复索引</h5><p>有时候有的同学有意或者无意的就对同一个列创建了多个索引，比方说这样写建表语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> person_info(<br>id <span class="hljs-type">INT</span> UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>birthday <span class="hljs-type">DATE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>phone_number <span class="hljs-type">CHAR</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>country <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br><span class="hljs-keyword">PRIMARY</span> KEY (id),<br>KEY idx_name_birthday_phone_number (name(<span class="hljs-number">10</span>), birthday, phone_number),<br>KEY idx_name (name(<span class="hljs-number">10</span>))<br>);<br></code></pre></td></tr></table></figure><p>我们知道，通过 idx_name_birthday_phone_number 索引就可以对 name 列进行快速搜索，再创建一个专门针对name 列的索引就算是一个 冗余 索引，维护这个索引只会增加维护的成本，并不会对搜索有什么好处。<br>另一种情况，我们可能会对某个列重复建立索引，比方说这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> repeat_index_demo (<br>c1 <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>c2 <span class="hljs-type">INT</span>,<br><span class="hljs-keyword">UNIQUE</span> uidx_c1 (c1),<br>INDEX idx_c1 (c1)<br>);<br></code></pre></td></tr></table></figure><p>c1 既是主键、又给它定义为一个唯一索引，还给它定义了一个普通索引，可是主键本身就会生成聚<br>簇索引，所以定义的唯一索引和普通索引是重复的，这种情况要避免</p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mysql数据行格式</title>
    <link href="/2021/10/24/Mysql%E6%95%B0%E6%8D%AE%E8%A1%8C%E6%A0%BC%E5%BC%8F/"/>
    <url>/2021/10/24/Mysql%E6%95%B0%E6%8D%AE%E8%A1%8C%E6%A0%BC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="InnnDB行格式"><a href="#InnnDB行格式" class="headerlink" title="InnnDB行格式"></a>InnnDB行格式</h2><p>MySQL服务器上负责对表中的数据读取和写入工作的部分是<strong>存储引擎</strong>,我们常用的存储引擎InnoDB,真实数据在不同存储引擎中存放的格式一般是不同的,InnoDB真正处理数据的过程是发生在内存中的,所以需要把磁盘的数据加载到内存中,如果是处理写入或者修改请求的话,还需要把内存中的记录刷新到磁盘上,磁盘的读写速度和内存相比非常慢,所以InnoDB采取的方式是:<strong>将数据划分为若干个页,以页作为磁盘和内存之间交互的基本单位,InnoDB中页的大小一般为16KB</strong>,也就是说,一次最少从磁盘读取16KB的内容到内存中,一次最少把内存中的16KB内存刷新到磁盘中。数据是以记录插入到表中的,记录的存放方式也被称为行格式,InnoDB有4种行格式,分别是<strong>Compact,Redundant,Dynamic,Compressed</strong> </p><h3 id="Compact行格式"><a href="#Compact行格式" class="headerlink" title="Compact行格式"></a>Compact行格式</h3><p><img src="https://199794.oss-cn-shanghai.aliyuncs.com/blog//snipaste_20201224_133417_1608788072352.png" alt="snipaste_20201224_133417.png"></p><h4 id="记录的额外信息"><a href="#记录的额外信息" class="headerlink" title="记录的额外信息"></a>记录的额外信息</h4><p>这里是描述记录的元信息,分别是变长字段长度列表,NULL值列表和记录头信息.<br>我们知道常用的一些变长数据类型,比如VARCHAR(M),VABINARY(M)等,变长字段存储多少字节的数据是不固定的,所以在存储真实数据的时候把数据占用的字节也存储起来.<br>创建一个示例: </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> record_format_demo (<br><span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> c1 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>),<br><span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> c2 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br><span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> c3 <span class="hljs-type">CHAR</span>(<span class="hljs-number">10</span>),<br><span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> c4 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>)<br><span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> ) CHARSET<span class="hljs-operator">=</span>ascii ROW_FORMAT<span class="hljs-operator">=</span>COMPACT;<br></code></pre></td></tr></table></figure><p>表中数据如下:<br><img src="https://199794.oss-cn-shanghai.aliyuncs.com/blog//snipaste_20201224_134654_1608788828570.png" alt="snipaste_20201224_134654.png"><br>在Compact行格式中,把所有变长字段的真实数据占用字节长度存放在记录的开头部位,从而形成一个变长字段长度列表,各变长字段数据占用的字节数按照列的顺序逆序存放,从这个例子来看,c1、c2、c4列都是变长类型的，都采用ascii字符集，所以每个字符只需要一个字节来编码，看一下，列的长度：<br><img src="https://199794.oss-cn-shanghai.aliyuncs.com/blog//snipaste_20201224_142251_1608790980798.png" alt="snipaste_20201224_142251.png"><br>查看一下记录实际效果：<br><img src="https://199794.oss-cn-shanghai.aliyuncs.com/blog//snipaste_20201224_142251_1608791049227.png" alt="snipaste_20201224_142251.png"></p><p>对于变长类型VARCHAR（M）来说，这种类型表示能存储最多M个字符，所以这个类型能表示的字符串最多占用的字节数就是M乘以编码最大表示字节数，比如utf8是3，utf8mb64是4，**如果该可变字段允许存储的最大字节数（M × W ）超过255字节并且真实存储的字节数（L）超过127字节，则使用2个字节，否则使用1个字节。  </p><p>需要注意：变长字段长度列表只存储值为非NULL的列内容占用的长度，值为NULL的列的长度是不存储的。</p><h4 id="NULL值列表"><a href="#NULL值列表" class="headerlink" title="NULL值列表"></a>NULL值列表</h4><p>表中某些列可能存储NULL值，如果把这些NULL值都放到记录的真实数据中存储会很占地方，所以Compact行格式把这些值为NULL的列统一管理起来，存储到NULL值列表中，处理过程如下：  </p><ol><li>统计表中的NULL值有哪些 </li><li>如果表中没有运行存储NULL的列，则NULL值列表也不存在了，否则将每个允许存储NULL的列对应一个二进制位，二进制位按照列的顺序逆序排列，1表示该列为null，0表示该列不为null。</li><li>规定NULL值列表必须用整个字节的位表示，如果使用的二进制位个数不是整个字节，则在字节的高位补0.</li></ol><p><img src="https://199794.oss-cn-shanghai.aliyuncs.com/blog//snipaste_20201224_142251_1608796397248.png" alt="snipaste_20201224_142251.png"></p><h4 id="记录头信息"><a href="#记录头信息" class="headerlink" title="记录头信息"></a>记录头信息</h4><p>除了变长字段长度列表，NULL值列表之外，还有一个用于描述记录的记录头信息，他是由固定的5个字节组成：<br><img src="https://199794.oss-cn-shanghai.aliyuncs.com/blog//snipaste_20201224_142251_1608796598727.png" alt="snipaste_20201224_142251.png">  </p><p><img src="https://199794.oss-cn-shanghai.aliyuncs.com/blog//snipaste_20201224_155719_1608796650444.png" alt="snipaste_20201224_155719.png"></p><h4 id="记录的真实数据"><a href="#记录的真实数据" class="headerlink" title="记录的真实数据"></a>记录的真实数据</h4><p>MySQL会为每个记录默认的添加一些列（隐藏列），具体如下：  </p><p><img src="https://199794.oss-cn-shanghai.aliyuncs.com/blog//snipaste_20201224_155929_1608796780750.png" alt="snipaste_20201224_155929.png"></p><p> InnoDB 表对主键的生成策略：优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个 Unique 键作为主键，如果表中连 Unique 键都没有定义的话，则 InnoDB 会为表默认添加一个名row_id 的隐藏列作为主键。所以我们从上表中可以看出：InnoDB存储引擎会为每条记录都添加 transaction_id和 roll_pointer 这两个列，但是 row_id 是可选的（在没有自定义主键以及Unique键的情况下才会添加该列）。这些隐藏列的值不用我们操心， InnoDB 存储引擎会自己帮我们生成的</p><p>因为例子没有定义主键,所以会为每条记录增加上述的3个列：<br><img src="https://199794.oss-cn-shanghai.aliyuncs.com/blog//snipaste_20201224_155929_1608797030169.png" alt="snipaste_20201224_155929.png"><br>注意几点：  </p><ol><li>表使用的是 ascii 字符集，所以 0x61616161 就表示字符串 ‘aaaa’ 0x626262 就表示字符串 ‘bbb’ </li><li>注意第1条记录中 c3 列的值，它是 CHAR(10) 类型的，它实际存储的字符串是： ‘cc’ ，而 ascii 字符集中的字节表示是 ‘0x6363’ ，虽然表示这个字符串只占用了2个字节，但整个 c3 列仍然占用了10个字节的空间，除真实数据以外的8个字节的统统都用空格字符填充，空格字符在 ascii 字符集的表示就是 0x20 </li><li>注意第2条记录中 c3 和 c4 列的值都为 NULL ，它们被存储在了前边的 NULL值列表 处，在记录的真实数据处就不再冗余存储，从而节省存储空间  </li></ol><h4 id="char-M-的存储格式"><a href="#char-M-的存储格式" class="headerlink" title="char(M)的存储格式"></a>char(M)的存储格式</h4><p>如果char(M)的字符集采用的也是变长字符集的话，也会记录到变长字段长度列表，</p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>了解迭代器</title>
    <link href="/2021/10/24/%E4%BA%86%E8%A7%A3%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <url>/2021/10/24/%E4%BA%86%E8%A7%A3%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>就是提供一种方法对一个容器对象中的各个元素进行访问,而又不暴露该对象容器的内部细节  </p><p>比如对于数据的遍历  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">int</span> <span class="hljs-keyword">array</span>[] = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">3</span>];    <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">array</span>.length; i++) &#123;<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">array</span>[i]);<br>&#125;<br></code></pre></td></tr></table></figure><p>对ArrayList的处理  </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">List</span>&lt;<span class="hljs-keyword">String</span>&gt; <span class="hljs-keyword">list</span> = <span class="hljs-keyword">new</span> ArrayList&lt;<span class="hljs-keyword">String</span>&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-keyword">list</span>.size() ;  i++)&#123;<br>           <span class="hljs-keyword">String</span> <span class="hljs-keyword">string</span> = <span class="hljs-keyword">list</span>.get(i);<br>&#125;<br>```    <br>对于这两种方式,我们知道他的内部结构,访问集合和集合本身是紧密耦合的,无法将访问逻辑和集合代码分离出来,不同的集合对应不同的访问方法,但是**<span class="hljs-built_in">Iterator</span>**,它总是用同一种逻辑来遍历集合,集合的内部状态由<span class="hljs-built_in">Iterator</span>来维护,客户端不用直接和集合打交道<br><br><span class="hljs-comment">### Iterable接口  </span><br><br><span class="hljs-keyword">Iterable</span>接口实现的功能是返回一个迭代器,该接口的<span class="hljs-built_in">iterator</span>()方法返回一个标准的<span class="hljs-built_in">Iterator</span>实现,实现<span class="hljs-keyword">Iterable</span>接口允许对象成为<span class="hljs-keyword">Foreach</span>语句的目标,就可以用过<span class="hljs-keyword">foreach</span>语句来遍历你的底层序列  <br><br>看看JDK8中定义的<span class="hljs-keyword">Iterable</span>接口<br></code></pre></td></tr></table></figure><p>public interface Iterable<T> {</p><p>//返回一个迭代器<br>Iterator<T> iterator();</p><p>default void forEach(Consumer&lt;? super T&gt; action) {<br>        Objects.requireNonNull(action);<br>        for (T t : this) {<br>            action.accept(t);<br>        }</p><p> default Spliterator<T> spliterator() {<br>        return Spliterators.spliteratorUnknownSize(iterator(), 0);<br>    }</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><br><span class="hljs-keyword">iterator</span>方法返回一个<span class="hljs-keyword">Iterator</span>接口 ,我们看看<span class="hljs-keyword">Iterator</span>接口:  <br><br></code></pre></td></tr></table></figure><p>public interface Iterator<E> {</p><p>  boolean hasNext();</p><p>  E next();</p><p>  default void remove() {<br>        throw new UnsupportedOperationException(“remove”);<br>  }</p><p>  default void forEachRemaining(Consumer&lt;? super E&gt; action) {<br>        Objects.requireNonNull(action);<br>        while (hasNext())<br>            action.accept(next());<br>  } </p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">简单实现一个迭代器:</span><br></code></pre></td></tr></table></figure><p>public class Test {</p><pre><code>public static void main(String[] args) &#123;    ReverseList&lt;String&gt; list=new ReverseList();    list.add(&quot;111&quot;);    list.add(&quot;222&quot;);    list.add(&quot;333&quot;);    Iterator&lt;String&gt; iterator = list.iterator();    while (iterator.hasNext())&#123;        System.out.println(iterator.next());    &#125;&#125;</code></pre><p>}</p><p>class ReverseList<T> implements Iterable<T> {</p><pre><code>private List&lt;T&gt; list = new ArrayList&lt;&gt;();public void add(T data) &#123;    list.add(data);&#125;@Overridepublic Iterator&lt;T&gt; iterator() &#123;    return new ReverIterator(list.size());&#125;private class ReverIterator implements Iterator&lt;T&gt; &#123;    int index;    ReverIterator(int size) &#123;        this.index = size;    &#125;    @Override    public void remove() &#123;        list.remove(index);    &#125;    @Override    public boolean hasNext() &#123;        return index&gt;0;    &#125;    @Override    public T next() &#123;        index--;        return list.get(index);    &#125;&#125;</code></pre><p>}</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><br><span class="hljs-comment">### 遍历元素</span><br><br>Java8为<span class="hljs-keyword">Iterable</span>接口新增了一个<span class="hljs-keyword">forEach</span>(Consumer action)方法,查看源码,其内部也是使用的 <span class="hljs-keyword">for</span> each遍历,在上面的例子中,我们使用<span class="hljs-keyword">Foreach</span>遍历<br></code></pre></td></tr></table></figure><p> ReverseList<String> list=new ReverseList();<br>        list.add(“111”);<br>        list.add(“222”);<br>        list.add(“333”);</p><pre><code>    list.forEach(x-&gt; System.out.println(x));</code></pre><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">也将得出反序的元素输出<br><br><span class="hljs-keyword">Java8为iterator新增的默认forEachRemaining方法,该方法可以用lamdba遍历集合 </span> <br><br></code></pre></td></tr></table></figure><p>ReverseList<String> list=new ReverseList();<br>        list.add(“111”);<br>        list.add(“222”);<br>        list.add(“333”);<br>Iterator<String> iterator = list.iterator();<br>iterator.forEachRemaining(x-&gt; System.out.println(x));</p><pre><code>### 快速失败机制当使用Iterator迭代访问Collection集合元素时,Collection集合里的元素不能被改变(**只有改变集合个数才会引发,使用list.set(index,element)方法改变某个元素时不会引发**),只有通过Iterator的remove()方法删除上一次next()方法返回的集合元素才可以,否则将会引发ModificationException异常.    </code></pre>]]></content>
    
    
    <categories>
      
      <category>JDK</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库与文件系统</title>
    <link href="/2021/10/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2021/10/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="数据库文件系统"><a href="#数据库文件系统" class="headerlink" title="数据库文件系统"></a>数据库文件系统</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">SHOW <span class="hljs-keyword">VARIABLES</span> LIKE <span class="hljs-comment">&#x27;datadir&#x27;</span>;<br></code></pre></td></tr></table></figure><p>可以查看数据库文件存储的位置 ,每个数据库都对应数据目录下的一个子目录，或者说对应一个文件夹，我们每当我们新建一个数据库时， MySQL 会帮我们做这两件事儿：</p><ol><li>在 数据目录 下创建一个和数据库名同名的子目录（或者说是文件夹）。</li><li>在该与数据库名同名的子目录下创建一个名为 db.opt 的文件，这个文件中包含了该数据库的各种属性，比方说该数据库的字符集和比较规则是个啥。</li></ol><h4 id="innodb是如何存储表数据的"><a href="#innodb是如何存储表数据的" class="headerlink" title="innodb是如何存储表数据的"></a>innodb是如何存储表数据的</h4><ol><li>innoDB是使用页为基本单位来管理存储空间的,默认页的大小为16kb.</li><li>对于InnoDB来说,每个索引都对应者一颗B+树,该B+树的每个节点都是一个数据页,数据页之间不必要是物理连续的,因为数据页之间有双向链表来维护着这些页的顺序.</li><li>InnoDB的聚簇索引的叶子节点存储了完整的用户记录,也就是所谓的索引即数据,数据即索引.</li></ol><p>为了管理这些页,设计们提出了表空间或文件空间的概念,表空间是一个抽象的概念,可以对应文件系统上一个或者多个真实文件,每个表空间可以被划分为很多很多页.表空间有不同的类型,下面来看看:</p><h5 id="系统表空间"><a href="#系统表空间" class="headerlink" title="系统表空间"></a>系统表空间</h5><p>系统表空间对应文件系统上一个或多个实际的文件,我们表中的数据都会被默认存储到这个系统表空间. InnoDB不会把各个表的数据存储到系统表空间中,而是为每一个表建立一个独立表空间,使用独立表空间会在该表所属的子目录下创建一个文件名和表名相同的扩展名为.ibd的文件.  </p><p>比方说假如我们使用独立表空间去存储xiaohaizi数据库下的test表,那么会在xiaohaizi目录下创建test.frm与test.idb</p><p>数据目录下有还一些其他文件: </p><ul><li>服务器进程文件</li><li>服务器日志文件<br>  比如常规的查询日志,错误日志,二进制日志,redo日志</li><li>默认/自动生成的SSL和RSA证书和密钥文件 </li></ul><h3 id="InnoDB的表空间"><a href="#InnoDB的表空间" class="headerlink" title="InnoDB的表空间"></a>InnoDB的表空间</h3><p>表空间中存储了各种页 </p><h4 id="区"><a href="#区" class="headerlink" title="区"></a>区</h4><p>为了更好的管理页,InnoDB设计者提出了区的概念,连续的64个页就是区(也就是一个区默认占用1MB空间大小),每256个区划分成1组,大概如下图所示:<br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-02-27_13-05-49_1614402368978.png" alt="Snipaste_20210227_130549.png">   </p><p><strong>为什么要引入区的概念?</strong><br>我们每向表中插入一条记录,本质上就是向该表的聚簇索引以及所有二级索引代表的B+树的节点插入数据,而B+树的每一层的页都会形成一个双向链表,如果是以页为单位来分配存储空间的话,双向链表相邻的两个页之间的物理位置可能隔的非常远,如果链表中相邻的两个页的物理位置离的非常远,就是所谓的随机IO,所以应该让链表中相邻的页的物理位置也相邻,这样可以使用所谓的顺序IO,所以才引入了区的概念,一个区就是在物理位置上连续的64个页,为某个索引分配空间的时候不再按照页为单位分配了,而是按照区为单位分配,甚至在表数据非常多的时候,可以一次性分配多个连续的区,虽然可能造成空间浪费,但是可以提高性能.  </p><p>我们知道范围查询其实是对B+树叶子节点中的记录进行顺序扫描,而如果不区分叶子节点和非叶子节点,统统把节点代表的页面放到区中,进行范围扫描效果就没有那么好,所以叶子节点有自己独有的区,非叶子节点也有自己独有的区存放叶子节点的区的集合就算一个段,存放非叶子节点的区的集合也算一个段,也就是索引会生成两个段,一个叶子节点段,一个非叶子节点段.  </p><h4 id="区的分类"><a href="#区的分类" class="headerlink" title="区的分类"></a>区的分类</h4><ul><li>空闲的区:现在还没有用到这个区的任何页面</li><li>有剩余空间的碎片区:表示碎片区中还有可用的页面</li><li>没有剩余空间的碎片区:表示碎片区中的所有页面都可以被使用,没有空闲页面.</li><li>附属于某个段的区.每个索引都可以分为叶子节点和非叶子节点,还有一些特殊作用的段.  </li></ul><p>为了方便管理这些区,设计了一个XDEC Entry的结构,每个区都对应着一个XDEC Entry结构,这个结构对应了区的一些属性,<br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-05-20_21-54-45_1621518904737.png" alt="Snipaste_20210520_215445.png"></p><ul><li>Segment ID<br>每一个段都有一个唯一编号,这里表示该区所在的段 </li><li>List Node<br>这个部分可以将XDES Entry结构组成一个链表  </li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>B+树索引</title>
    <link href="/2021/10/24/B-%E6%A0%91%E7%B4%A2%E5%BC%95/"/>
    <url>/2021/10/24/B-%E6%A0%91%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<p>对于非主键的查找过程是如何? </p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>如果想要快速的找到数据在哪个页,我没必须为数据页也建立一个目录,建这个目录必须完成下面这些事:  </p><ul><li>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值. </li></ul><p>下面展示数据页模型的简单示例:<br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-02-24_23-52-00_1614181930113.png" alt="Snipaste_20210224_235200.png"><br> 黄色代表主键,由于数据页不是连续的,在向表中插入许多数据后,可能是这样的效果:<br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-02-24_23-54-45_1614182094657.png" alt="Snipaste_20210224_235445.png"><br>下面我们为这几个页做目录,每个目录项包含以下内容:  </p><ol><li>页的用户记录中最小的主键值,我们用key表示</li><li>页号,我们用page_no表示</li></ol><p><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-02-24_23-56-59_1614182231093.png" alt="Snipaste_20210224_235659.png"> </p><p>比方说我们想找主键值为20的记录,查找过程分两步:  </p><ul><li>从目录项中根据二分法确定主键值为20的记录在目录3(12&lt;20&lt;209),它对应的页是页9.</li><li>再在页内定位具体的记录.</li></ul><p>我们上面假设的是目录项在物理上连续存储的,假如某个页面删除了,那么后面的目录项都需要向前移动,这种设计导致牵一发而动全身,所以设计者复用了之前存储用户记录的数据页来存储目录项,为了和用户记录做区分,使用record_type=1来记录,如下图所示:<br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-02-25_09-43-24_1614217415599.png" alt="Snipaste_20210225_094324.png">  </p><p>一个页的大小为16kb,如果一个页放不下所有的目录项,则需要多个页来存储,如下图所示:<br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-02-25_09-49-14_1614217764039.png" alt="Snipaste_20210225_094914.png">  </p><p>我们现在查询需要定位到目录项记录的页,那么我们怎么根据主键值快速定位到存储目录项记录的页呢,可以继续为目录项记录再生成一个高级记录页,如下图所示: </p><p><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-02-25_09-53-56_1614218049365.png" alt="Snipaste_20210225_095356.png"><br>这其实就是一个B+树,实际的用户记录其实都存放在B+树的最底层节点上,也就是叶子节点,其余用来存储目录项的节点称为非叶子节点.  </p><h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><ol><li>使用记录主键值的大小进行记录和页的排序,包括三方面的含义: <ul><li>页内的记录按照主键大小顺序排成一个单项链表</li><li>各个存放用户记录的页根据用户记录的主键大小顺序排成一个双向链表</li><li>存放目录项记录放在不同层次,在同一层次中的页也是根据页中目录项记录的主键大小排成一个双向链表</li></ul></li><li>B+树的叶子节点存储的是完整的用户记录(就是指这个记录存储了所以列的值)</li></ol><p>聚簇索引并不需要我们使用index语句去创建,InnoDB存储引擎会自动的为我们创建聚簇索引,在InnoDB存储引擎中,聚簇索引就是数据的存储方式,也就是所谓的索引即数据,数据即索引.   </p><h4 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h4><p>如果我们想用别的列作为搜索条件,我们可以再新建一个B+树,比如说我们使用C2列的大小作为数据页,页中记录的排序规则,再新建一个B+树,如下图所示:<br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-02-25_10-14-06_1614219266875.png" alt="Snipaste_20210225_101406.png"></p><p>这个B+树与聚簇索引的不同之处: </p><ul><li><p>使用记录c2列的大小进行记录和页的排序,包含3个方面的含义:  </p><ul><li>页内记录是按照c2列大小顺序排成一个单向链表</li><li>各个存放用户记录的页也是根据页中记录的c2列大小顺序排成一个双向链表</li><li>存放目录项记录的页分为不同的层次,在同一层次中的页也是根据页中目录项记录的c2大小顺序排成双向链表</li></ul></li><li><p>B+树的叶子节点存储的不是完整的用户记录,而只是c2列+主键 这两个列的值</p></li><li><p>目录项记录中不再是主键+页号,而是c2+页号</p></li></ul><p>现在根据c2(查找c2=4)查找过程如下: </p><ol><li>确定目录项记录页(可以快速定位到目录项记录所在的页内42,因为2&lt;4&lt;9)</li><li>通过目录项记录页确定用户记录真实所在的页,可以确定在页34和35中</li><li>在页中定位到具体的记录,由于叶子节点只存储了c2和c1,所以我们必须再根据主键去聚簇索引中再查找一遍完整的用户记录,这个过程也称为<strong>回表</strong></li></ol><p>因为这种按照非主键建立的B+树需要一次回表操作才可以定位到完整的记录,所以这种B+树也被称为二级索引,或者辅助索引.</p><h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>我们也可以同时以多个列的大小作为排序规则,也就是同时为多个列建立索引,比如让B+树按照c2列和c3列的大小进行排序: </p><ul><li>先把各个记录和页按照c2列进行排序</li><li>在记录的c2列相同的情况下,采用c3列进行排序.</li></ul><p><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-02-25_13-15-00_1614230113213.png" alt="Snipaste_20210225_131500.png">  </p><h4 id="建立索引"><a href="#建立索引" class="headerlink" title="建立索引"></a>建立索引</h4><p>InnoDB和MyISAM会自动为主键或者声明为UNIQUE的列去自动建立B+数索引,或者手动建立:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> index_demo(<br>c1 <span class="hljs-type">INT</span>,<br>c2 <span class="hljs-type">INT</span>,<br>c3 <span class="hljs-type">CHAR</span>(<span class="hljs-number">1</span>),<br><span class="hljs-keyword">PRIMARY</span> KEY(c1),<br>INDEX idx_c2_c3 (c2, c3)<br>);<br><br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ADD</span> [INDEX<span class="hljs-operator">|</span>KEY] 索引名 (需要被索引的单个列或多个列);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>从数据页到索引</title>
    <link href="/2021/10/24/%E4%BB%8E%E6%95%B0%E6%8D%AE%E9%A1%B5%E5%88%B0%E7%B4%A2%E5%BC%95/"/>
    <url>/2021/10/24/%E4%BB%8E%E6%95%B0%E6%8D%AE%E9%A1%B5%E5%88%B0%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h4 id="数据页"><a href="#数据页" class="headerlink" title="数据页"></a>数据页</h4><p>数据页是InnoDB管理内存空间的基本单位，InnoDB有不同类型的页，比如存放头部空间的页，存放node信息的页，存放undo日志的页，存放表中记录的页，被官方称为索引。  </p><h4 id="数据页的结构"><a href="#数据页的结构" class="headerlink" title="数据页的结构"></a>数据页的结构</h4><p><img src="https://199794.oss-cn-shanghai.aliyuncs.com/blog//snipaste_20201228_203542_1609158949200.png" alt="snipaste_20201228_203542.png"><br>看一下各个部分的简单介绍<br><img src="https://199794.oss-cn-shanghai.aliyuncs.com/blog//snipaste_20201228_203729_1609159062208.png" alt="snipaste_20201228_203729.png"><br>我们自己存储的记录会按指定的行格式存储到User Records部分，每插入一条记录，都会从Free Space 部分，也就是尚未使用的存储空间申请一个记录大小空间划分到User Records部分。  </p><p>创建一个案例： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> page_demo(<br><span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> c1 <span class="hljs-type">INT</span>,<br><span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> c2 <span class="hljs-type">INT</span>,<br><span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> c3 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10000</span>),<br><span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">PRIMARY</span> KEY (c1)<br><span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> ) CHARSET<span class="hljs-operator">=</span>ascii ROW_FORMAT<span class="hljs-operator">=</span>Compact;<br></code></pre></td></tr></table></figure><p>看一下示例表的行格式：<br><img src="https://199794.oss-cn-shanghai.aliyuncs.com/blog//snipaste_20201228_211835_1609161553051.png" alt="snipaste_20201228_211835.png"><br>我们再复习下记录头信息里的各个属性：<br><img src="https://199794.oss-cn-shanghai.aliyuncs.com/blog//snipaste_20201228_214340_1609163036258.png" alt="snipaste_20201228_214340.png"><br>我们向表中插入几条数据：  </p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">mysql</span>&gt; <span class="hljs-selector-tag">INSERT</span> <span class="hljs-selector-tag">INTO</span> <span class="hljs-selector-tag">page_demo</span> <span class="hljs-selector-tag">VALUES</span>(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;aaaa&#x27;</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">200</span>, <span class="hljs-string">&#x27;bbbb&#x27;</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">300</span>, <span class="hljs-string">&#x27;cccc&#x27;</span>),<br>(<span class="hljs-number">4</span>, <span class="hljs-number">400</span>, <span class="hljs-string">&#x27;dddd&#x27;</span>);<br></code></pre></td></tr></table></figure><p><img src="https://199794.oss-cn-shanghai.aliyuncs.com/blog//snipaste_20201228_220219_1609164157246.png" alt="snipaste_20201228_220219.png"></p><p><strong>delete_mask</strong>:<br>标志着数据是否被删除，所有被删除的记录都会组成一个垃圾链表，这个链表被称为<strong>可重用空间</strong>，如果之后又新记录插入到表中，可能把这些空间覆盖掉<br><strong>min_rec_mask</strong>:<br>B+树的每层非叶子节点中的最小记录都会添加该记录，插入的4条记录的min_rec_mask值都是0，意味着他们都不是B+书的非叶子节点中的最小记录。<br><strong>heap_no</strong>:<br> 表示当前记录在本页中的位置，InnoDB存在两个伪记录，一个代表最小记录，一个代表最大记录，记录怎么比大小，比较记录的大小就是比较主键的大小，但是不管向页中插入多少记录，两条伪纪录都是固定的，如图所示：<br><img src="https://199794.oss-cn-shanghai.aliyuncs.com/blog//snipaste_20201229_232318_1609255411366.png" alt="snipaste_20201229_232318.png"><br>这两条记录被单独放在Infimum+Supremum部分。 最小记录和最大记录的heap_no值分别是0和1，也就是说他们的位置最靠前。<br><strong>record_type</strong>:<br>这个属性表示记录的类型，0表示普通记录，1表示B+书非叶子节点记录，2表示最小记录，3表示最大记录。<br><strong>next_record</strong>:<br>表示从当前记录的真实数据到下一条记录真实数据的地址偏移量,可以通过一条记录找到它的一条记录,这其实是个链表,下一条记录指的并不是按照我们插入顺序的下一条记录,而是按照主键值由小到大的顺序的下一条记录,而且规定最小记录的下一条记录就是本页中主键值最小的用户记录,而本页中主键值最大的用户记录的下一条记录就是最大记录.<br><img src="https://199794.oss-cn-shanghai.aliyuncs.com/blog//snipaste_20201230_230910_1609340961966.png" alt="snipaste_20201230_230910.png"><br>当我们把第2条记录删除:<br><img src="https://199794.oss-cn-shanghai.aliyuncs.com/blog//snipaste_20201230_232233_1609341761316.png" alt="snipaste_20201230_232233.png"><br>删除第二条记录后我们可以发现这些变化:  </p><ul><li>第二条记录并没有从存储空间移除,而是把该条记录的delete_mask值设置为1</li><li>第二条记录的next_record值变成0,表示该记录没有下一条记录</li><li>第一条记录的next_record指向了第三条记录</li><li>最大记录的n_owned值变成了4  </li></ul><h4 id="Page-Directory-页目录"><a href="#Page-Directory-页目录" class="headerlink" title="Page Directory(页目录)"></a>Page Directory(页目录)</h4><p>普通的一条查询语句,最笨的方法是从最小记录开始,沿着链表一直往后找,但是mysql设计者想到了更好的办法,从目录中得到如下方式:  </p><ol><li>将所有正常的记录(包括最大记录和最小记录)划分为几个组</li><li>每个组的最后一条记录的头信息中的n_owned属性表示该组拥有多少条记录</li><li>将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到Page Directory,也就是页目录,页目录中的这些地址偏移量被称为槽点(slot),所以这个页面目录就是由槽组成的.  </li></ol><p><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-02-24_22-44-00_1614177884019.png" alt="Snipaste_20210224_224400.png">  </p><p><strong>对于最小记录所在的分组只能有1条记录,最大记录所在的分组拥有的记录条数只能在1~8条之间,剩下的分组中记录的条数在4-8条之间,所以分组是按照下边的步骤进行的</strong>:  </p><ol><li>初始情况下一个数据页里只有最小记录和最大记录两条,属于两个分组</li><li>之后每插入一条数据,都会从页目录中找到主键值比本记录值大并且差值最小的槽,然后把该槽对应的记录的n_owned值加1,直到组内有8条数据</li><li>在一个组的记录等于8时,再插入一条数据时,会将组拆分为两个组,一个组中4条记录,另一个5条记录,并在页目录中新增一个槽来记录这个新增分组的最大记录偏移量.  </li></ol><p>所以在一个数据页中查找指定主键值的记录的过程分为两步:</p><ol><li>通过二分法确定该记录所在的槽,并找到该槽中主键值最小的那条记录 </li><li>通过记录的next_record属性遍历该槽所在的组中的各个记录 </li></ol><h3 id="页面头部"><a href="#页面头部" class="headerlink" title="页面头部"></a>页面头部</h3><p>为了能得到一个数据页中存储的记录的状态信息,比如本页中已经存储了多少记录,第一条记录的地址是什么,页目录中存储了多少个槽等等.这些信息存储在Page Header部分.</p><h3 id="文件部分"><a href="#文件部分" class="headerlink" title="文件部分"></a>文件部分</h3><p>File Header 主要记录了页的一些通用信息,比如这个页的编号是多少,它上一个页,下一个页是多少等等</p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis慢查询与事务</title>
    <link href="/2021/10/24/Redis%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%B8%8E%E4%BA%8B%E5%8A%A1/"/>
    <url>/2021/10/24/Redis%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%B8%8E%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h3><p>我们知道,redis执行命令有4个步骤:</p><ol><li>发送命令</li><li>命令排队</li><li>执行命令</li><li>返回结果</li></ol><p>慢查询只统计步骤3的时间<br>对于慢查询功能，需要明确两件事：</p><ul><li>预设阀值怎么设置？</li><li>慢查询记录存放在哪？</li></ul><p>Redis提供了slowlog-log-slower-than和slowlog-max-len配置来解决这两个<br>问题。从字面意思就可以看出，slowlog-log-slower-than就是那个预设阀值,它的单位是微秒（1秒=1000毫秒=1000000微秒），默认值是10000，假如执行了一条“很慢”的命令（例如keys*），如果它的执行时间超过了10000微秒，那么它将被记录在慢查询日志中。 </p><p>从字面意思看，slowlog-max-len只是说明了慢查询日志最多存储多少条，并没有说明存放在哪里？实际上Redis使用了一个列表来存储慢查询日志，slowlog-max-len就是列表的最大长度。一个新的命令满足慢查询条件时被插入到这个列表中，当慢查询日志列表已处于其最大长度时，最早插入的一个命令将从列表中移出，例如slowlog-max-len设置为5，当有第6条慢查询插入的话，那么队头的第一条数据就出列，第6条慢查询就会入列。</p><p>虽然慢查询日志是存放在Redis内存列表中的，但是Redis并没有暴露这个列表的键，而是通过一组命令来实现对慢查询日志的访问和管理。  </p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务表示一组动作，要么全部执行，要么全部不执行。例如在社交网站上用户A关注了用户B，那么需要在用户A的关注表中加入用户B，并且在用户B的粉丝表中添加用户A，这两个行为要么全部执行，要么全部不执行，否则会出现数据不一致的情况。<br>Redis提供了简单的事务功能，将一组需要一起执行的命令放到multi和exec两个命令之间。multi命令代表事务开始，exec命令代表事务结束，它们之间的命令是原子顺序执行的</p><p>例如下面操作实现了上述用户关注问题</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; multi<br>OK<br><span class="hljs-number">127.0.0.1:6379</span>&gt; sadd user:a:follow user:b<br>QUEUED<br><span class="hljs-number">127.0.0.1:6379</span>&gt; sadd user:b:fans user:a<br>QUEUED<br></code></pre></td></tr></table></figure><p>Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p><h4 id="Redis事务没有隔离级别的概念"><a href="#Redis事务没有隔离级别的概念" class="headerlink" title="Redis事务没有隔离级别的概念:"></a>Redis事务没有隔离级别的概念:</h4><p>批量操作在发送EXEC命令前被放入到队列缓存,并不会被实际执行,也就不存在事务内的查询要看到事务内的更新,事务外查询不能看到.  </p><h4 id="Redis不保证原子性"><a href="#Redis不保证原子性" class="headerlink" title="Redis不保证原子性:"></a>Redis不保证原子性:</h4><p>Redis中,单条命令是原子性执行的,但事务不保证原子性,且没有回滚,事务中任意命令执行失败,其余的命令仍会被执行.</p><h4 id="事务的三个阶段"><a href="#事务的三个阶段" class="headerlink" title="事务的三个阶段"></a>事务的三个阶段</h4><ul><li>开始事务</li><li>命令入队</li><li>执行事务</li></ul><p>Redis事务相关命令:<br>watch key1 key2…:监视一个或多个key,被监视的key被其他命令改动,则事务被打断</p><p>Redis使用WATCH命令来决定事务是继续执行还是回滚，那就需要在MULTI之前使用WATCH来监控某些键值对，然后使用MULTI命令来开启事务，执行对数据结构操作的各种命令，此时这些命令入队列。</p><p>当使用EXEC执行事务时，首先会比对WATCH所监控的键值对，如果没发生改变，它会执行事务队列中的命令，提交事务；如果发生变化，将不会执行事务中的任何命令，同时事务回滚。当然无论是否回滚，Redis都会取消执行事务前的WATCH命令。<br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-03-01_21-41-09_1614606087741.png" alt="Snipaste_20210301_214109.png"></p><h4 id="若在事务队列中存在命令性错误（类似于java编译性错误），则执行EXEC命令时，所有命令都不会执行"><a href="#若在事务队列中存在命令性错误（类似于java编译性错误），则执行EXEC命令时，所有命令都不会执行" class="headerlink" title="若在事务队列中存在命令性错误（类似于java编译性错误），则执行EXEC命令时，所有命令都不会执行"></a>若在事务队列中存在命令性错误（类似于java编译性错误），则执行EXEC命令时，所有命令都不会执行</h4><p><img src="http://oss.xiaokoua.cn/blog//1659331-20190416205137740-1887538258_1614606203528.png" alt="1659331201904162051377401887538258.png">  </p><h4 id="若在事务队列中存在语法性错误（类似于java的1-0的运行时异常），则执行EXEC命令时，其他正确命令会被执行，错误命令抛出异常。"><a href="#若在事务队列中存在语法性错误（类似于java的1-0的运行时异常），则执行EXEC命令时，其他正确命令会被执行，错误命令抛出异常。" class="headerlink" title="若在事务队列中存在语法性错误（类似于java的1/0的运行时异常），则执行EXEC命令时，其他正确命令会被执行，错误命令抛出异常。"></a>若在事务队列中存在语法性错误（类似于java的1/0的运行时异常），则执行EXEC命令时，其他正确命令会被执行，错误命令抛出异常。</h4><p><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-03-01_21-44-01_1614606257014.png" alt="Snipaste_20210301_214401.png">  </p><p> 使用watch检测balance，在开启事务后（标注1处），在新窗口执行标注2中的操作，更改balance的值，模拟其他客户端在事务执行期间更改watch监控的数据，然后再执行标注1后命令，执行EXEC后，事务未成功执行。<br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-03-01_21-46-05_1614606382969.png" alt="Snipaste_20210301_214605.png"></p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL执行计划</title>
    <link href="/2021/10/24/SQL%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/"/>
    <url>/2021/10/24/SQL%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h3 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h3><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>执行上面sql语句,将得到下面执行计划:<br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-03-10_17-06-16_1615367395708.png" alt="Snipaste_20210310_170616.png">  </p><p>解释一下每个字段的意思:  </p><ul><li>id  在一个大的查询语句中每个 SELECT 关键字都对应一个唯一的 id</li><li>select_typ SELECT 关键字对应的那个查询的类型</li><li>table 表名 </li><li>partitions 匹配的分区信息</li><li>possible_keys 可能用到的索引</li><li>key 实际上使用的索引</li><li>key_len 实际使用到的索引长度</li><li>ref  当使用索引列等值查询时，与索引列进行等值匹配的对象信息</li><li>rows 预估的需要读取的记录条数</li><li>filtered 某个表经过搜索条件过滤后剩余记录条数的百分比</li><li>Extra 一些额外的信息 </li></ul><p>我们看一下连接查询</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">explain</span> select * FROM test<span class="hljs-number">1</span> t<span class="hljs-number">1</span> INNER JOIN test<span class="hljs-number">2</span> t<span class="hljs-number">2</span> <span class="hljs-literal">on</span> t<span class="hljs-number">1</span>.guid=t<span class="hljs-number">2</span>.guid<br></code></pre></td></tr></table></figure><p><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-03-10_17-21-17_1615368088190.png" alt="Snipaste_20210310_172117.png">  </p><h5 id="id"><a href="#id" class="headerlink" title="id"></a>id</h5><p>查询语句中每出现一个 SELECT 关键字，MySQL就会为它分配一个唯一的 id值。<br>对于连接查询来说，一个 SELECT 关键字后边的 FROM 子句中可以跟随多个表，所以在连接查询的执行计划中，每个表都会对应一条记录，但是这些记录的id值都是相同的.出现在前边的表表示驱动表，出现在后边的表表示被驱动表  </p><p>对于包含 UNION 子句的查询语句来说，每个 SELECT 关键字对应一个 id 值也是没错的，不过还是有点儿特别的:  </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table s1 <span class="hljs-keyword">WHERE</span> s1.key1 = <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table s2 <span class="hljs-keyword">WHERE</span> s2.key1 = <span class="hljs-string">&#x27;a&#x27;</span><br></code></pre></td></tr></table></figure><p><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-03-10_18-00-11_1615370425433.png" alt="Snipaste_20210310_180011.png"></p><p>UNION字句会把多个查询的结果集合并起来并对结果集中的记录进行去重,怎么去重? 它使用的是内部临时表,正如上边的查询计划中表示,UNION字句是为了把id为1的查询和id为2的查询结果集合并起来并去重,所以在内部创建了一个名为&lt;union1,2&gt;的临时表,跟 UNION 对比起来， UNION ALL 就不需要为最终的结果集进行去重，它只是单纯的把多个查询的结果集中的记录合并成一个并返回给用户，所以也就不需要使用临时表。所以在包含 UNION ALL 子句的查询的执行计划中，就没有那个 id 为 NULL 的记录  </p><h5 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h5><ul><li><p>simple 查询语句中不包含UNION或者子查询的都算做SIMPLE类型,比如单表查询和连接查询.  </p></li><li><p>primary 对于包含UNION,UNION ALL 或者子查询的大查询来说,它是由几个小查询组成的,其中最左边的那个查询的select_type 值就是primary,比方说:  </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table s1 <span class="hljs-keyword">WHERE</span> s1.key1 = <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> single_table s2 <span class="hljs-keyword">WHERE</span> s2.key1 = <span class="hljs-string">&#x27;a&#x27;</span><br></code></pre></td></tr></table></figure><p><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-03-10_21-19-07_1615382364591.png" alt="Snipaste_20210310_211907.png">  </p></li><li><p>union 对于包含 UNION 或者 UNION ALL 的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询以外，其余的小查询的 select_type 值就是 UNION,临时表就是<strong>UNION RESULT</strong> </p></li><li><p>SUBQUERY 如果包含子查询的查询语句不能转为对应的emi-join的形式,并且该子查询是不相关子查询,并且查询优化器决定采用将该子查询物化的方式来执行该子查询时,该子查询的第一个select关键字代表的那个查询的select_type就是SUBQUERY,比如下面的查询:  </p></li><li><p>DEPENDENT SUBQUERY  如果包含子查询的查询语句不能够转为对应的 semi-join 的形式，并且该子查询是相关子查询，则该子查询的第一个 SELECT 关键字代表的那个查询的 select_type 就是 DEPENDENT SUBQUERY,<strong>select_type为DEPENDENT SUBQUERY的查询可能会被执行多次</strong></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">EXPLAIN SELECT<br>* <br>FROM<br>single_table <span class="hljs-built_in">s1</span> <br>WHERE<br><span class="hljs-built_in">s1</span>.key1 IN ( SELECT <span class="hljs-built_in">s2</span>.key1 FROM single_table <span class="hljs-built_in">s2</span> WHERE <span class="hljs-built_in">s1</span>.key2 = <span class="hljs-built_in">s2</span>.key2 ) <br><span class="hljs-keyword">OR </span><span class="hljs-built_in">s1</span>.key3 = <span class="hljs-string">&#x27;a&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>DEPENDENT UNION </p></li></ul>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL 表访问方式揭秘</title>
    <link href="/2021/10/24/SQL-%E8%A1%A8%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F%E6%8F%AD%E7%A7%98/"/>
    <url>/2021/10/24/SQL-%E8%A1%A8%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F%E6%8F%AD%E7%A7%98/</url>
    
    <content type="html"><![CDATA[<h2 id="单表访问方法"><a href="#单表访问方法" class="headerlink" title="单表访问方法"></a>单表访问方法</h2><p>对于单表查询来说,查询的执行方式大致分为以下两种: </p><ul><li>使用全表扫描进行查询</li><li>使用索引进行查询  </li></ul><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>我们可以直接通过主键列来定位一条记录,比如我们创建一个案例: </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">table</span> (<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>key1 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>key2 <span class="hljs-type">INT</span>,<br>key3 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>key_part1 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>key_part2 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>key_part3 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>common_field <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br><span class="hljs-keyword">PRIMARY</span> KEY (id),<br>KEY idx_key1 (key1),<br><span class="hljs-keyword">UNIQUE</span> KEY idx_key2 (key2),<br>KEY idx_key3 (key3),<br>KEY idx_key_part(key_part1, key_part2, key_part3)<br>) Engine<span class="hljs-operator">=</span>InnoDB CHARSET<span class="hljs-operator">=</span>utf8;<br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">1438</span>;<br></code></pre></td></tr></table></figure><p><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-05-20_22-07-28_1621519662111.png" alt="Snipaste_20210520_220728.png">  </p><h3 id="ref访问方式"><a href="#ref访问方式" class="headerlink" title="ref访问方式"></a>ref访问方式</h3><p>看看使用二级索引并回表方式的查询步骤:  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> k2=<span class="hljs-number">3841</span><br></code></pre></td></tr></table></figure><p><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-05-20_22-10-32_1621519842586.png" alt="Snipaste_20210520_221032.png">  </p><p>注意以下几个情况:  </p><ul><li>无论普通二级索引还是唯一二级索引,它们的索引列对包含null值得数量并不限制,所以我们采用 key is null 这种形式的搜索条件最多只能使用ref的访问方法而不是const的访问方法.  </li><li>对于包含多个索引列的二级索引来说,只要是最左边连续的索引列与常数的等值比较就可能采用ref的访问方法:  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> key_part1=<span class="hljs-string">&#x27;god like&#x27;</span> <span class="hljs-keyword">and</span> key_part12=<span class="hljs-string">&#x27;legendary&#x27;</span> <span class="hljs-keyword">and</span> key_part3=<span class="hljs-string">&#x27;pent&#x27;</span><br></code></pre></td></tr></table></figure>但是如果最左边的连续索引列并不全是等值比较的话,它的访问方法就不能称为ref了,比如:  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> key_part1=<span class="hljs-string">&#x27;god like&#x27;</span> <span class="hljs-keyword">and</span> key_part2&gt; <span class="hljs-string">&#x27;leng&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="ref-or-null"><a href="#ref-or-null" class="headerlink" title="ref_or_null"></a>ref_or_null</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> *  <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> key1=<span class="hljs-string">&#x27;abc&#x27;</span> <span class="hljs-keyword">or</span> key1 <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span> <br></code></pre></td></tr></table></figure><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-05-20_22-25-16_1621520726788.png" alt="Snipaste_20210520_222516.png">  </li></ul><h3 id="range"><a href="#range" class="headerlink" title="range"></a>range</h3><p>range 就是对于某个key 进行范围查询,略.. </p><h3 id="index"><a href="#index" class="headerlink" title="index"></a>index</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> key_part1,key_part2,key_part3 <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> key_part2=<span class="hljs-string">&#x27;abc&#x27;</span> <br></code></pre></td></tr></table></figure><p>由于 key_part2 并不是联合索引idx_key_part最左边索引列,所以我们无法使用ref或者range访问方法来执行这个语句,但是这个语句刚好是覆盖索引,而且key_part2 也在此索引中,也就是说我们可以通过遍历idex_key_part索引的叶子节点的记录来比较key_part2=’abc’ 这个条件是否成立,把成功匹配的假如结果集,这种采用遍历二级索引记录的执行方式称为index.  </p><h3 id="all"><a href="#all" class="headerlink" title="all"></a>all</h3><p>全表扫描,就是直接扫描聚簇索引  </p><h3 id="有的搜索条件无法使用索引的情况"><a href="#有的搜索条件无法使用索引的情况" class="headerlink" title="有的搜索条件无法使用索引的情况"></a>有的搜索条件无法使用索引的情况</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> key2 &gt; <span class="hljs-number">100</span> <span class="hljs-keyword">OR</span> common_field = <span class="hljs-string">&#x27;abc&#x27;</span>;<br>```  <br>我们把使用不到 idx_key2 索引的搜索条件替换为 <span class="hljs-keyword">TRUE</span><br></code></pre></td></tr></table></figure><p>SELECT * FROM single_table WHERE key2 &gt; 100 OR TRUE</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">接着简化  <br></code></pre></td></tr></table></figure><p>SELECT * FROM single_table WHERE TRUE;</p><pre><code>也就是说一个使用到索引的搜索条件和没有使用该索引的搜索条件使用or连接起来后是无法使用该索引的.  ### 索引合并  使用到多个索引来完成一次查询的执行方法称之为： index merge   #### Intersection合并mysql在特定的情况下才可能会使用到Intersection索引合并:  - 情况一: 二级索引是等值匹配的情况,对于联合索引来说,在联合索引中的每个列都必须等值匹配,不能出现只出现匹配部分列的情况.  - 情况二:主键可以是范围查询,二级索引必须是等值匹配,因为只有在这种情况下根据二级索引查询出的结果集是按照主键值排序的.  #### union合并  - 情况一: 二级索引是等值匹配的情况,对于联合索引来说,在联合索引中的每个列都必须等值匹配,不能出现只匹配部分列的情况  - 情况二:主键列可以是范围匹配 - 情况三: 使用 Intersevtion索引合并的搜索条件  </code></pre>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Buffer Pool</title>
    <link href="/2021/10/24/Buffer-Pool/"/>
    <url>/2021/10/24/Buffer-Pool/</url>
    
    <content type="html"><![CDATA[<h2 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h2><p>如何调节磁盘与CPU的矛盾? 数据存放在表空间的页中,是存储在磁盘上,但是磁盘的速度很慢,所以数据库在处理数据时会把数据加载到内存中,当需要访问某个页的数据时,就会把完整的页全部加载到内存中,也就是说即使我们只需要访问一个页的一条记录,那也需要先把完整的页数据加载到内存中.  在进行完读写访问之后并不着急把该页对应的内存空间释放掉,而是将其缓存起来,这样将来再有请求访问该页面时,就可以省去IO开销  </p><p>为了管理这些页,mysql为他们建立了控制信息块,每个缓存页对应的控制信息占用的内存大小是相同的,把控制信息占用的内存称为控制块,控制块和缓存页是一一对应的,他们都被放到Buffer pool中<br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-05-22_09-19-47_1621646402945.png" alt="Snipaste_20210522_091947.png">    </p><p>启动mysql的时候,会对buffer pool启动初始化操作,随着程序运行,会有数据页缓存到buffer pool上,<br>为了记录buffer Pool中哪些页是可用的,把所有空闲的缓存页对应的控制块作为一个节点放到一个链表中,<br>这个链表称为free链表<br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-05-22_18-06-49_1621678031553.png" alt="Snipaste_20210522_180649.png">  </p><p>有了这个free链表之后就好办事了,每当需要从磁盘加载一个页到Buffer Pool中时,就从free链表中取一个空闲的缓存页,并且把该缓存页对应的控制块信息填上,然后把该缓存页对应的free链表节点从链表中移除,表示该缓存页已经被使用了.  </p><h3 id="flush链表管理"><a href="#flush链表管理" class="headerlink" title="flush链表管理"></a>flush链表管理</h3><p>如果我们修改了Buffer Pool中某个缓存页的数据,那么就和磁盘页不一致了,但是并不会马上刷新到硬盘上,那么如何管理这些刷新的<strong>脏页</strong>,mysql做出如下措施:凡是修改过的缓存页的控制块都加入到一个叫flush链表的结构中,假设某个时间点Buffer Pool中脏页的数量为n,那么对应的flush链表长这样:  </p><p><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-05-22_22-27-23_1621694161782.png" alt="Snipaste_20210522_222723.png">   </p><h3 id="LRU链表"><a href="#LRU链表" class="headerlink" title="LRU链表"></a>LRU链表</h3><p>当Buffer Pool中不再有空闲的缓存页,需要淘汰最近很少使用的缓存页,为了按照最近最少使用的原则区淘汰缓存页的,所以这个链表可以被称为LRU链表,当我们需要访问某个页时:  </p><ul><li>如果该页不在Buffer Pool中,在把该页从磁盘加载到Buffer Pool中的缓存页时,就把该缓存页对应的控制块作为节点塞到链表头部  </li><li>如果该页已经缓存在Buffer Pool中,则直接把该页对应的控制块移动到LRU链表头部    </li></ul><p>也就是说:<strong>只要我们使用到某个缓存页,就把该缓存页调整到LRU链表的头部,这样LRU链表尾部就是最近最少使用的缓存页</strong>  </p><h3 id="划分区域的预读"><a href="#划分区域的预读" class="headerlink" title="划分区域的预读"></a>划分区域的预读</h3><p>  由于mysql存在预读机制:  </p><ul><li>线性预读: 异步读取下一个区的页到Buffer pool </li><li>随机预读: 如果Buffer Pool中已经缓存了某个区的13个连续页面,就会触发异步读取本区中所有的页面到Buffer Pool的请求   </li></ul><p>为了防止使用频率偏低的页面缓存到Buffer Pool中把使用频率非常高的页从Buffer Pool中淘汰掉  </p><p>因为这种情况的存在,所以LRU链表按照一定比例分成两截:  </p><ul><li>热数据区,或称为young区域  </li><li>冷数据区,称为old区域  </li></ul>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库事务</title>
    <link href="/2021/10/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/"/>
    <url>/2021/10/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务?"></a>什么是事务?</h2><p>事务是逻辑上的一组操作,要么都执行,要么都不执行  </p><p>比如现实中的转账业务,一个加钱,一个减钱,必须都成功 </p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>要么全都做,要么全不做的规则称之为原子性  </p><h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>现实世界中的两次状态转换应该是互不影响的，比如说狗哥向猫爷同时进行的两次金额为5元的转账（假设可以在两个ATM机上同时操作）。那么最后狗哥的账户里肯定会少10元，猫爷的账户里肯定多了10元。但是到对应的数据库世界中，事情又变的复杂了一些。  </p><ul><li>读取狗哥账户的余额到变量A中，这一步骤简写为 read(A)   </li><li>将狗哥账户的余额减去转账金额，这一步骤简写为 A = A - 5 </li><li>将狗哥账户修改过的余额写到磁盘里，这一步骤简写为 write(A </li><li>读取猫爷账户的余额到变量B，这一步骤简写为 read(B)</li><li>将猫爷账户的余额加上转账金额，这一步骤简写为 B = B + 5</li><li>将猫爷账户修改过的余额写到磁盘里，这一步骤简写为 write(B)</li></ul><p>我们将狗哥向猫爷同时进行的两次转账操作分别称为 T1 和 T2 ，在现实世界中 T1 和 T2 是应该没有关系的，可以先执行完 T1 ，再执行 T2 ，或者先执行完 T2 ，再执行 T1 ，对应的数据库操作就像这样<br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-05-23_11-24-14_1621740267013.png" alt="Snipaste_20210523_112414.png"><br>真实的数据库中 T1 和 T2 的操作可能交替执行<br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-05-23_11-25-11_1621740327638.png" alt="Snipaste_20210523_112511.png"><br>所以隔离性为并发访问数据库时,一个用户的事务不会被其他事务所干扰,各并发事务之间数据库是独立的  </p><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>比如转账业务,每完成一笔交易后,都需要保证整个系统的余额不变,无论事务是否成功,转账者和收款人的总额不变  </p><h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><p>一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。  </p><h3 id="事务的状态"><a href="#事务的状态" class="headerlink" title="事务的状态"></a>事务的状态</h3><p>根据事务执行的不同阶段,事务大致上划分成了几个状态:  </p><ul><li> <strong>活动的(active)</strong>  事务对应的数据库操作正在执行过程中时,我们就说该事务处在活动的状态  </li><li><strong>部分提交的(partially commited)</strong> 当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并没有刷新到磁盘时，我们就说该事务处在 部分提交的 状态。  </li><li><strong>失败的（failed)</strong> 当事务处在 活动的 或者 部分提交的 状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在 失败的 状态.  </li><li><strong>中止的（aborted)</strong> 如果事务执行了半截而变为 失败的 状态，比如我们前边唠叨的狗哥向猫爷转账的事务，当狗哥账户的钱被<br>扣除，但是猫爷账户的钱没有增加时遇到了错误，从而当前事务处在了 失败的 状态，那么就需要把已经修改的狗哥账户余额调整为未转账之前的金额，换句话说，就是要撤销失败事务对当前数据库造成的影响。书面一点的话，我们把这个撤销的过程称之为 回滚 。当 回滚 操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了 中止的 状态。  </li><li><strong>提交的（committed）</strong> 当一个处在 部分提交的 状态的事务将修改过的数据都同步到磁盘上之后，我们就可以说该事务处在了 提交的 状态。  </li></ul><p><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-05-23_11-48-45_1621741735441.png" alt="Snipaste_20210523_114845.png"></p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Netty入门</title>
    <link href="/2021/10/24/Netty%E5%85%A5%E9%97%A8/"/>
    <url>/2021/10/24/Netty%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><p>同步与异步关注的是消息通信机制,同步就是在发出一个调用时,在没有得到结果之前,该调用就不返回,但是一旦调用返回,就得到返回值了<br>而异步相反,调用在发出之后,这个调用就立即返回了,所以没有返回结果,当一个异步过程调用发出之后,调用者不会立即得到结果,而是在调用发出之后,被调用者通过状态,通知来通知调用者,或者通过回调函数来处理这个调用  </p><h2 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h2><p>阻塞与非阻塞关注的是程序在等待调用结果时的状态<br>阻塞调用是指调用结果返回之前,当前线程会被挂起,调用线程只有在得到结果之后才会返回.<br>非阻塞调用指的是不能立即得到结果之前,该调用不会阻塞当前线程.  </p><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-05-23_23-31-12_1621783890886.png" alt="Snipaste_20210523_233112.png">  </p><h3 id="事件和Channel"><a href="#事件和Channel" class="headerlink" title="事件和Channel"></a>事件和Channel</h3><p>Netty的时间按照入站或出站数据流的相关性进行分类,可能由入站数据或者相关的状态更改而触发的事件包括:  </p><ul><li>连接已被激活或者连接失活;</li><li>数据读取</li><li>用户事件</li><li>错误事件</li></ul><p>出站事件是未来将会触发的某个操作结果: </p><ul><li>打开或者关闭到远程借点的链接</li><li>将数据冲刷到套接字</li></ul><p>Netty的事件可以分发给ChannelHandler处理:<br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-06-14_11-32-32_1623643897654.png" alt="Snipaste_20210614_113232.png">  </p><h3 id="选择器-事件和EventLoop"><a href="#选择器-事件和EventLoop" class="headerlink" title="选择器,事件和EventLoop"></a>选择器,事件和EventLoop</h3><p>在内部,Netty将会为每个Channel分配一个EventLoop,用以处理所有事件,包括: </p><ul><li>注册感兴趣的事件</li><li>将事件派发给ChannelHandler</li><li>安排进一步的动作</li></ul><h3 id="ChannelPipeline接口"><a href="#ChannelPipeline接口" class="headerlink" title="ChannelPipeline接口"></a>ChannelPipeline接口</h3><p>ChannelPipline提供了ChannelHandler链的容器,当Channel被创建时,它会被自动的分配到它专属的ChannelPipeline. Channelhandler安装到ChannelPipeline中的过程如下:  </p><ul><li>一个ChannelInitializer的实现被注册到了ServerBootstrap中;</li><li>当ChannelInitiazer.initChannel()方法被调用时,ChannelInitializer将在ChannelPipeline中安装一组自定义的ChannelHandler;</li><li>ChannelInitializer将它自己从ChannelPipeline中移除</li></ul>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>## 同步与异步</title>
    <link href="/2021/10/24/%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/"/>
    <url>/2021/10/24/%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SSO</title>
    <link href="/2021/10/24/SSO/"/>
    <url>/2021/10/24/SSO/</url>
    
    <content type="html"><![CDATA[<h2 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h2><p>当用户第一次访问应用系统1的时候,因为还没有登录,会被引导到认证系统进行登录:根据用户提供的登录信息,认证系统进行身份验证,如果通过校验,应该返回给用户一个认证的凭据—ticket;用户再访问别的应用的时候就会将这个ticket带上,作为自己的凭据,应用系统接收到请求之后会把ticket送到认证系统进行校验,检验ticket的合法性,如果通过校验,用户可以在不用再次登录的情况下访问应用系统2等..  </p><p>要实现SSO, 需要以下主要的功能:  </p><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>CAS是central Authentication Service的缩写,中央认证服务,一种独立开放指令协议,是开源的企业级单点登录解决方案.  </p><p>CAS 包括两部分:CAS Server和CAS Client </p><p>CAS Server负责完成对用户的认证工作,会为用户签发两个重要的票据:登录票据(TGT)和服务票据(ST)来实现认证过程,CAS Server需要独立部署.  </p><p>CAS Client 负责处理对客户端受保护资源的访问请求,需要对请求方进行身份认证时,重定向到CAS Server进行认证,准确的说,Client一般会以拦截器实现保护资源,对于访问受保护资源的每个web请求,CAS Client会解析请求是否包含Service Ticket(服务票据)  </p><h4 id="核心票据"><a href="#核心票据" class="headerlink" title="核心票据"></a>核心票据</h4><p>CAS的核心就是Ticket,CAS的主要票据有TGT,ST,PGT,PGTIOU,PT,其中TGT,ST是CAS1.0协议中就有的票据,PGT,PGTIOU,PT是CAS2.0协议中有的票据.  </p><h5 id="TGT"><a href="#TGT" class="headerlink" title="TGT"></a>TGT</h5><p>TGT是CAS为用户签发的登录票据,拥有了TGT,用户就可以证明自己在CAS成功登录过,TGT封装了cookie值以及Cookie值对应的用户信息,用户在CAS认证成功后,生成一个TGT对象,放入自己的缓存,可以是session或Redis,同时CAS生成cookie(其实就是TGT的sessionId) 或者生成一个token给浏览器(token可以跨域),当http再次请求到来时,如果传来有CAS生成cookie,则CAS以此seesionId为key查询缓存中有无TGT,如果有的话,则说明用户之前登录过,如果没有,则用户需要重新登录.  </p><h5 id="TGC"><a href="#TGC" class="headerlink" title="TGC"></a>TGC</h5><p>CAS Server 生成TGT放入自己的缓存中,而TGC就是这个缓存的唯一标识  </p><h5 id="ST"><a href="#ST" class="headerlink" title="ST"></a>ST</h5><p>ST是CAS为用户签发的访问某一服务票据,用户访问service时,用户访问service时,service发现用户没有ST,则要求用户去CAS获取ST,用户向CAS发出获取ST的请求,如果用户的请求包含cookie,则CAS会以此cookie值为key查询缓存中有无TGT,如果存在TGT,则用此TGT签发一个ST,返回给用户.用户凭借ST去访问service,service拿ST去CAS验证,验证通过后,允许用户访问资源.   </p><p>为了保证ST的安全性,ST是基于随机生成的,而且CAS规定ST只能存活一定的时间,而且CAS协议规定ST只能使用一次,无论Service Ticket验证是否成功,CAS Service 都会清楚服务端中的该Ticket,从而可以确保一个Service Ticket不被使用两次 .  </p><p><a href="https://blog.csdn.net/wang379275614/article/details/46337529">https://blog.csdn.net/wang379275614/article/details/46337529</a></p>]]></content>
    
    
    <categories>
      
      <category>SSO</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ArrayList源码</title>
    <link href="/2021/10/24/ArrayList%E6%BA%90%E7%A0%81/"/>
    <url>/2021/10/24/ArrayList%E6%BA%90%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyArrayList</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterable</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CAPACITY = <span class="hljs-number">10</span>;  <span class="hljs-comment">//初始容量</span><br><br>    <span class="hljs-keyword">transient</span> Object[] elementData;<br><br>    <span class="hljs-comment">//空数组实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;<br><br>    <span class="hljs-comment">//默认空数组实例,以了解添加第一个元素时,空间需要扩大多少</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<br><br>    <span class="hljs-comment">//与快速失败机制有关的属性,记录容器大小是否更改</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> modCount = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//虚拟机规定的最大数组大小,超过可能会引发OutOfMemoryError</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="hljs-number">8</span>;<br><br>    <span class="hljs-comment">//数组大小</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyArrayList</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyArrayList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">this</span>.elementData = <span class="hljs-keyword">new</span> Object[initialCapacity];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;容量错误&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;<br>        <span class="hljs-comment">//todo</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>        <span class="hljs-comment">//保证容量</span><br>        ensureCapacityInternal(size + <span class="hljs-number">1</span>);<br>        elementData[size++] = e;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculateCapacity</span><span class="hljs-params">(Object[] elementData, <span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>            <span class="hljs-keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);<br>        &#125;<br>        <span class="hljs-keyword">return</span> minCapacity;<br><br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>        modCount++;<br>        <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>) &#123;<br>            grow(minCapacity);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//扩容核心方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">grow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> oldCapacity = elementData.length;<br>        <span class="hljs-comment">//这边右移一位表示一半,所以扩容为原来的1.5大小</span><br>        <span class="hljs-keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>) &#123;<br>            newCapacity = minCapacity;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>) &#123;<br>            newCapacity = hugeCapacity(minCapacity);<br>        &#125;<br>        <span class="hljs-comment">//复制扩容数组</span><br>        elementData = Arrays.copyOf(elementData, newCapacity);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; index &lt; size; index++) &#123;<br>                <span class="hljs-keyword">if</span> (elementData[index] == <span class="hljs-keyword">null</span>) &#123;<br>                    fastRemove(index);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; index &lt; size; index++) &#123;<br>                <span class="hljs-keyword">if</span> (o.equals(elementData[index])) &#123;<br>                    fastRemove(index);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fastRemove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        modCount++;<br>        <span class="hljs-keyword">int</span> numMoved = size - index - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>) &#123;<br>            System.arraycopy(elementData, index + <span class="hljs-number">1</span>, elementData, index, numMoved);<br>        &#125;<br>        elementData[--size] = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hugeCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapaCity)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (minCapaCity &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OutOfMemoryError();<br>        &#125;<br>        <span class="hljs-keyword">return</span> minCapaCity &gt; MAX_ARRAY_SIZE ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;<br>    &#125;<br><br>    <span class="hljs-comment">//返回迭代器</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//内部迭代器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Itr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>        <span class="hljs-keyword">int</span> curosr;  <span class="hljs-comment">//下一个元素index</span><br>        <span class="hljs-keyword">int</span> lastRet = -<span class="hljs-number">1</span>;  <span class="hljs-comment">//  最后一个元素的index;</span><br><br>        <span class="hljs-keyword">int</span> expectedModCount = modCount;  <span class="hljs-comment">//快速失败机制</span><br><br>        Itr() &#123;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> curosr != size;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>            checkForComodification();<br>            <span class="hljs-keyword">int</span> i = curosr;<br>            <span class="hljs-keyword">if</span> (i &gt;= size) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();<br>            &#125;<br><br>            Object[] elementData = MyArrayList.<span class="hljs-keyword">this</span>.elementData;<br>            <span class="hljs-keyword">if</span> (i &gt;= elementData.length) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();<br>            &#125;<br>            curosr = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span> (E) elementData[lastRet = i];<br><br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (lastRet &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException();<br>            &#125;<br>            checkForComodification();<br>            MyArrayList.<span class="hljs-keyword">this</span>.remove(lastRet);<br>            curosr = lastRet;<br>            lastRet = -<span class="hljs-number">1</span>;<br>            expectedModCount = modCount;<br><br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkForComodification</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (modCount != expectedModCount) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JDK</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HashMap</title>
    <link href="/2021/10/24/HashMap/"/>
    <url>/2021/10/24/HashMap/</url>
    
    <content type="html"><![CDATA[<p>HashMap 实现了Map接口,允许放入key为null的元素,也允许插入value为null的元素,除该类未实现同步外,其余跟hashtable大致相同,跟TreeMap不同,该容器不保证元素顺序,容器可能会对元素重新hash,元素的顺序也会被打散,因此不同时间迭代同一个hashMap的顺序可能会不同. java解决hash冲突的办法是冲突链表方法.  </p><p><img src="http://oss.xiaokoua.cn/blog//HashMap_base_1627094785616.png" alt="HashMap_base.png">  </p><p>有两个参数可以影响HashMap的性能:初始容量(inital capacity)和负载系数(load factor).初始容量指定了初始table的大小,负载系数用来指定自动扩容的临界值.当entry的数量超过capacity*load_factor时,容器将自动扩容并重新hash,对于插入元素较多的场景,将初始容量设大可以减少重新hash的次数.  </p><p>将对象放到HashMap时,需要特点关注Hashcode()和equals()方法,hashCode()方法决定了对象会被放到哪个bucket里,当多个对象的hash值冲突时,equals()方法决定了这些对象是否是”同一个对象”  </p>]]></content>
    
    
    <categories>
      
      <category>JDK</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二进制逻辑运算回顾</title>
    <link href="/2021/10/24/%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E5%9B%9E%E9%A1%BE/"/>
    <url>/2021/10/24/%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E5%9B%9E%E9%A1%BE/</url>
    
    <content type="html"><![CDATA[<p>逻辑变量之间的称为逻辑运算,二进制1和0在逻辑上可以代表”真”与”假”,”是”与”否”<br>计算机的逻辑运算主要包括三种基本运算:逻辑加法(又称”或”运算),逻辑乘法(又称”与”运算)和逻辑否定(又称”非”运算),此外还有”异或”运算.  </p><h3 id="或运算"><a href="#或运算" class="headerlink" title="或运算"></a>或运算</h3><p>逻辑加法通常用符号”+”或符号”∨”来表示,逻辑加法的运算规则如下:<br>0+0=0, 0∨0=0<br>0+1=1, 0∨1=1<br>1+1=1, 1∨1=1<br>1+0=1, 1∨0=1</p><h3 id="与运算"><a href="#与运算" class="headerlink" title="与运算"></a>与运算</h3><p>逻辑乘运算通常用符号”x”或”∧”来表示,逻辑乘法运算规则如下:<br>0x0=0 0∧0=0<br>0x1=0 0∧1=0<br>1x0=0 1∧0=0<br>1x1=1 1∧1=1</p><h3 id="非运算"><a href="#非运算" class="headerlink" title="非运算"></a>非运算</h3><p>逻辑非运算又称逻辑否运算。其运算规则为：<br>0=1 非0等于1<br>1=0 非1等于0</p><h3 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h3><p>异或运算用符号⊕表示,运算规则为:<br>a⊕b=(¬a∧b)∨(a∧¬b)<br>0⊕0=0 0同0异或，结果为0<br>0⊕1=1 0同1异或，结果为1<br>1⊕0=1 1同0异或，结果为1<br>1⊕1=0 1同1异或，结果为0</p><p>即两个逻辑变量相异,输出才为1 ,口诀相同取0,相异取1   </p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis底层数据结构</title>
    <link href="/2021/10/24/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2021/10/24/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis底层数据结构"><a href="#Redis底层数据结构" class="headerlink" title="Redis底层数据结构"></a>Redis底层数据结构</h1><h2 id="简单动态字符串-SDS"><a href="#简单动态字符串-SDS" class="headerlink" title="简单动态字符串(SDS)"></a>简单动态字符串(SDS)</h2><p>redis构建了一种名为简单动态字符串(SDS)的数据结构,并将SDS作为redis的默认字符串表示。<br>除了用来保存字符串值外，SDS还被用作缓冲区：AOF模块中的AOF持久化，以及客户端状态中的输入缓冲区<br>SDS的结构:  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sdshdr</span> &#123;</span><br><br>    <span class="hljs-comment">// 记录 buf 数组中已使用字节的数量</span><br>    <span class="hljs-comment">// 等于 SDS 所保存字符串的长度</span><br>    <span class="hljs-keyword">int</span> len;<br><br>    <span class="hljs-comment">// 记录 buf 数组中未使用字节的数量</span><br>    <span class="hljs-keyword">int</span> <span class="hljs-built_in">free</span>;<br><br>    <span class="hljs-comment">// 字节数组，用于保存字符串</span><br>    <span class="hljs-keyword">char</span> buf[];<br><br>&#125;; <br></code></pre></td></tr></table></figure><ul><li>free 属性的值为 0 ， 表示这个 SDS 没有分配任何未使用空间</li><li>len 属性的值为 5 ， 表示这个 SDS 保存了一个五字节长的字符串</li><li>buf 属性是一个 char 类型的数组， 数组的前五个字节分别保存了 ‘R’ 、 ‘e’ 、 ‘d’ 、 ‘i’ 、 ‘s’ 五个字符， 而最后一个字节则保存了空字符 ‘\0’   </li></ul><h4 id="SDS具有的优势："><a href="#SDS具有的优势：" class="headerlink" title="SDS具有的优势："></a>SDS具有的优势：</h4><blockquote><p>常数复杂度获取字符串长度    </p></blockquote><p>因为SDS数据结构中保存了字符串的长度,所以与C语言遍历字符数组相比，SDS获取字符串长度的时间复杂度为O(1)    </p><blockquote><p> 防止缓冲区溢出  </p></blockquote><p>C语言不记录自身长度带来的另一个问题是容易造成缓冲区溢出,比如对字符串append操作时,SDS会检查SDS的空间是否满足修改的需求，如果不满足的话，SDS会进行扩容操作, 防止缓冲区溢出，在SDS中,buf数组长度不一定就是字符串数量加一,数组可以包含未使用的字节,SDS使用free属性记录未使用空间，因为内存重分配是一个比较耗时的操作，当需要扩容时，SDS实现<strong>空间预分配</strong>操作，如果对SDS修改后的长度小于1MB，<strong>这里的修改后的长度是指的append操作之后的长度</strong>，SDS会分配和len长度一样的空间作为预备空间，当修改后的长度大于1MB，那么redis会为SDS分配1MB的未使用空间，当SDS进行类似trim操作时，SDS实现<strong>惰性空间释放</strong>操作，就是说，SDS并没有释放多出来的free空间，如果将来要对字符串增长的话，那么未使用空间将会派上用场  </p><blockquote><p>二进制安全</p></blockquote><p> C字符串中的字符必须符合某种编码，除了字符串的末尾，字符串里面是不能包含空字符的，否则会被认为是字符串结尾，这些限制了C字符串只能保存文本数据，而不能保存像图片这样的二进制数据 , 而SDS的API都会以处理二进制的方式来处理存放在<code>buf</code>数组里的数据，不会对里面的数据做任何的限制。SDS使用<code>len</code>属性的值来判断字符串是否结束，而不是空字符 </p><blockquote><p> 兼容部分C字符串函 </p></blockquote><p> 虽然SDS的API是二进制安全的，但还是像C字符串一样以空字符结尾，目的是为了让保存文本数据的SDS可以重用一部分C字符串的函数 </p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p> 链表是一种比较常见的数据结构了，特点是易于插入和删除、内存利用率高、且可以灵活调整链表长度，但随机访问困难。许多高级编程语言都内置了链表的实现，但是C语言并没有实现链表，所以Redis实现了自己的链表数据结构 ，链表在redis中应用非常广泛，列表的底层实现就是链表，redis的发布与订阅，慢查询，监视器等功能都用到了链表。 Redis服务器本身还使用链表来保存多个客户端的状态信息，以及使用链表来构建客户端输出缓冲区。    </p><p>链表节点的定义如下：  </p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs gauss">typedef <span class="hljs-keyword">struct</span> <span class="hljs-type">listNode</span> &#123;<br><br>    <span class="hljs-comment">// 前置节点</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-type">listNode</span> *prev;<br><br>    <span class="hljs-comment">// 后置节点</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-type">listNode</span> *next;<br><br>    <span class="hljs-comment">// 节点的值</span><br>    void *value;<br><br>&#125;<br>listNode;  <br></code></pre></td></tr></table></figure><p>多个listNode可以通过prev和next指针组成双端链表,如下图:</p><p><img src="http://oss.xiaokoua.cn//617219185-d6dbc0ae3b47b326_fix732.png"></p><p> 虽然仅仅使用多个 listNode 结构就可以组成链表， 但使用 adlist.h/list 来持有链表的话， 操作起来会更方便：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span> &#123;</span><br><br>    <span class="hljs-comment">// 表头节点</span><br>    listNode *head;<br><br>    <span class="hljs-comment">// 表尾节点</span><br>    listNode *tail;<br><br>    <span class="hljs-comment">// 链表所包含的节点数量</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> len;<br><br>    <span class="hljs-comment">// 节点值复制函数</span><br>    <span class="hljs-keyword">void</span> *(*dup)(<span class="hljs-keyword">void</span> *ptr);<br><br>    <span class="hljs-comment">// 节点值释放函数</span><br>    <span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*free)(<span class="hljs-keyword">void</span> *ptr);<br><br>    <span class="hljs-comment">// 节点值对比函数</span><br>    <span class="hljs-built_in"><span class="hljs-keyword">int</span></span> (*match)(<span class="hljs-keyword">void</span> *ptr, <span class="hljs-keyword">void</span> *key);<br><br>&#125; list;<br></code></pre></td></tr></table></figure><p> list 结构为链表提供了表头指针 head 、表尾指针 tail ， 以及链表长度计数器 len ， 而 dup 、 free 和 match 成员则是用于实现多态链表所需的类型特定函数： </p><ul><li><p>dup 函数用于复制链表节点所保存的值；</p></li><li><p>free 函数用于释放链表节点所保存的值；</p></li><li><p>match 函数则用于对比链表节点所保存的值和另一个输入值是否相等。 </p></li></ul><p><img src="http://oss.xiaokoua.cn//2574488259-b43b7b2798e92e99_fix7322.png">  </p><h4 id="链表特性"><a href="#链表特性" class="headerlink" title="链表特性"></a>链表特性</h4><ul><li><p>双端： 链表节点带有 prev 和 next 指针， 获取某个节点的前置节点和后置节点的复杂度都是 O(1) 。</p></li><li><p>无环： 表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL ， 对链表的访问以 NULL 为终点。</p></li><li><p>带表头指针和表尾指针： 通过 list 结构的 head 指针和 tail 指针， 程序获取链表的表头节点和表尾节点的复杂度为 O(1) 。</p></li><li><p>带链表长度计数器： 程序使用 list 结构的 len 属性来对 list 持有的链表节点进行计数， 程序获取链表中节点数量的复杂度为 O(1) 。</p></li><li><p>多态： 链表节点使用 void* 指针来保存节点值， 并且可以通过 list 结构的 dup 、 free 、 match 三个属性为节点值设置类型特定函数， 所以链表可以用于保存各种不同类型的值。     </p></li></ul><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>Redis 数据库底层就是用字典实现的，对数据库的增、删、改、查操作都是构建在对字典的操作之上，比如： </p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">set</span> msg <span class="hljs-comment">&quot;hello world&quot;</span><br>OK<br></code></pre></td></tr></table></figure><p>创建一个 key 为 “msg”，value 为 “hello world” 的键值对，保存在代表数据库的字典中<br>字典还是哈希键的底层实现之一： 当一个哈希键包含的键值对比较多， 又或者键值对中的元素都是比较长的字符串时， Redis 就会使用字典作为哈希键的底层实现。<br>哈希表结构定义</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictht</span> &#123;</span><br><br>    <span class="hljs-comment">// 哈希表数组</span><br>    dictEntry **table;<br><br>    <span class="hljs-comment">// 哈希表大小</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> size;<br><br>    <span class="hljs-comment">// 哈希表大小掩码，用于计算索引值</span><br>    <span class="hljs-comment">// 总是等于 size - 1</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> sizemask;<br><br>    <span class="hljs-comment">// 该哈希表已有节点的数量</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> used;<br><br>&#125; dictht;<br></code></pre></td></tr></table></figure><p>table 属性是一个数组， 数组中的每个元素都是一个指向 dict.h/dictEntry 结构的指针， 每个 dictEntry 结构保存着一个键值对。<br>size 属性记录了哈希表的大小， 也即是 table 数组的大小， 而 used 属性则记录了哈希表目前已有节点（键值对）的数量。<br>sizemask 属性的值总是等于 size - 1 ， 这个属性和哈希值一起决定一个键应该被放到 table 数组的哪个索引上面。</p><h4 id="哈希节点"><a href="#哈希节点" class="headerlink" title="哈希节点"></a>哈希节点</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> &#123;</span><br><br>    <span class="hljs-comment">// 键</span><br>    <span class="hljs-keyword">void</span> *key;<br><br>    <span class="hljs-comment">// 值</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-keyword">void</span> *val;<br>        <span class="hljs-keyword">uint64_t</span> u64;<br>        <span class="hljs-keyword">int64_t</span> s64;<br>    &#125; v;<br><br>    <span class="hljs-comment">// 指向下个哈希表节点，形成链表</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> *<span class="hljs-title">next</span>;</span><br><br>&#125; dictEntry;<br></code></pre></td></tr></table></figure><p>key 属性保存着键值对中的键， 而 v 属性则保存着键值对中的值， 其中键值对的值可以是一个指针， 或者是一个 uint64_t 整数， 又或者是一个 int64_t 整数。<br>next 属性是指向另一个哈希表节点的指针， 这个指针可以将多个哈希值相同的键值对连接在一次， 以此来解决键冲突（collision）的问题。  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk">typedef struct dict &#123;<br>    <span class="hljs-regexp">//</span> 和类型相关的处理函数<br>    dictType *type;<br>    <span class="hljs-regexp">//</span> 私有数据<br>    void *privdata;<br>    <span class="hljs-regexp">//</span> 哈希表<br>    dictht ht[<span class="hljs-number">2</span>];<br>    <span class="hljs-regexp">//</span> rehash 索引，当rehash不再进行时，值为-<span class="hljs-number">1</span><br>    long rehashidx; <span class="hljs-regexp">/* rehashing not in progress if rehashidx == -1 */</span><br>    <span class="hljs-regexp">//</span> 迭代器数量<br>    unsigned long iterators; <span class="hljs-regexp">/* number of iterators currently running */</span><br>&#125; dict;<br></code></pre></td></tr></table></figure><p>ht属性是一个包含两个项的数组,数组中的每一个项都是一个dictht哈希表,一般情况下,字典只使用ht[0]哈希表,  ht[1]哈希表只会在ht[0]哈希表进行rehash时使用.  </p><p><code>rehashidx</code>也是rehash相关的,rehash的操作不是瞬间完成的,rehashidx记录着rehash的进度,如果目前没有正在进行rehash,它的值为-1  </p><h4 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h4><p>当将一个新的键值对插入到字典,需要重新计算索引值,redis计算索引的方法是:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 使用字典设置的哈希函数，计算键 key 的哈希值</span><br><span class="hljs-attr">hash</span> = dict-&gt;type-&gt;hashFunction(key)<span class="hljs-comment">;</span><br><br><span class="hljs-comment"># 使用哈希表的 sizemask 属性和哈希值，计算出索引值</span><br><span class="hljs-comment"># 根据情况不同， ht[x] 可以是 ht[0] 或者 ht[1]</span><br><span class="hljs-attr">index</span> = hash &amp; dict-&gt;ht[x].sizemask<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>类似Java的HashMap,计算key的hash值,然后hash&amp;(len-1),而redis的sizemask就是size-1  </p><h4 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h4><p>当出现hash冲突时,redis使用的是链地址法来解决冲突,链地址法就是将冲突的节点构成一个链表放在该索引位置上,redis采用的是头插法,解决hash冲突的还有三种方法.分别是:开放地址法, 开放定址法（线性探测再散列，二次探测再散列，伪随机探测再散列）、再哈希法以及建立一个公共溢出区  </p><h4 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h4><p> 随着不断的操作，hash表中的键值对可能会增多或减少，为了让哈希表的负载因子保持在一个范围内，需要对 hash表进行扩容或收缩，收缩和扩容的过程就叫 rehash。rehash 过程如下：  </p><ol><li><p>为字典的 ht[1] 哈希表分配空间， 这个哈希表的空间大小取决于要执行的操作， 以及 ht[0] 当前包含的键值对数量 （也即是 ht[0].used 属性的值）  </p><ul><li> 如果执行的是扩展操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used * 2 的 2^n （2 的 n 次方幂） </li><li> 如果执行的是收缩操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used 的 2^n </li></ul></li><li><p>  将保存在 ht[0] 中的所有键值对 rehash 到 ht[1] 上面： rehash 指的是重新计算键的哈希值和索引  值， 然后将键值对放置到 ht[1] 哈希表的指定位置上 </p></li><li><p>  当 ht[0] 包含的所有键值对都迁移到了 ht[1] 之后 （ht[0] 变为空表）， 释放 ht[0] ， 将 ht[1] 设置为 ht[0] ,  并在 ht[1] 新创建一个空白哈希表， 为下一次 rehash 做准备 </p></li></ol><h5 id="当以下条件中的任意一个被满足时，-程序会自动开始对哈希表执行扩展操作："><a href="#当以下条件中的任意一个被满足时，-程序会自动开始对哈希表执行扩展操作：" class="headerlink" title="当以下条件中的任意一个被满足时， 程序会自动开始对哈希表执行扩展操作："></a><strong>当以下条件中的任意一个被满足时， 程序会自动开始对哈希表执行扩展操作：</strong></h5><ul><li>服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 1 ；</li><li>服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 5 ；<br>其中哈希表的负载因子可以通过公式：<code>load_factor = ht[0].used / ht[0].size</code>计算 ,比如说,对于一个大小为4,包含4个键值对的哈希表来说,这个哈希表的负载因子为:<code>load_factor=4/4=1</code></li></ul><p>根据BGSAVE命令或者BGREWRITEAOF命令是否正在执行,服务器执行扩展操作所需要的负载因子并不相同,这是因为在执行BGSAVE命令或BGREWRITEAOF命令过程中,Redis需要创建当前服务器的子进程,而大多数操作系统都是采用写时复制(copy-on-write)技术来优化子进程的使用效率,所以在子进程存在期间,服务器会提高执行扩展操作所需要的负载因子,从而尽可能的避免在子进程存在期间进行哈希表扩展操作,这样可以避免不必要的内存写入操作,最大程度的节约内存.  </p><h4 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h4><p>当数据量大的时候一次性进行迁移会造成服务器在一段时间内定制服务,为了避免因为庞大的计算量导致服务器在一段时间内停止服务,redis采用渐进式将ht[0]键值对rehash到ht[1].  </p><p> 以下是哈希表渐进式 rehash 的详细步骤： </p><ol><li> 为 ht[1] 分配空间， 让字典同时持有 ht[0] 和 ht[1] 两个哈希表 </li><li> 在字典中维持一个索引计数器变量 rehashidx ， 并将它的值设置为 0  , 表示 rehash 工作正式开始 . </li><li> 在rehash进行期间,每次对字典执行添加,删除,查找或者更新操作时,程序除了执行指定的操作外,还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1].当rehash工作完成之后,程序将rehashidx属性的值加1.  </li><li> 随着字典操作不断执行,最终在某个时间点上,ht[0]的所有键值对都会被rehash到ht[1],这时程序将rehashidx属性的值设为-1,表示rehash操作已经完成.  </li></ol><h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><p>跳跃表示一种有序数据结构,它通过在每个节点中维持指向其他节点的指针,从而达到快速访问节点的目的.  </p><p>下面详细介绍跳跃表:  </p><p><img src="http://oss.xiaokoua.cn//Snipaste_2021-10-31_15-19-22.png"></p><p>现在我们有个场景,想快速找到上图单链表中的这10歌元素,只能从头开始遍历,这样的查找效率很低,那么有没有提高查找效率的方法呢?如下图所示，我们从链表中每两个元素抽出来，加一级索引，一级索引指向了原始链表， 即：通过一级索引 7 的down指针可以找到原始链表的 7 。那现在怎么查找 10 这个元素呢  </p><p><img src="http://oss.xiaokoua.cn//Snipaste_2021-10-31_15-23-24.png"></p><p>先在索引找1,4,7,9遍历到一级索引的9时,发现后继节点是13,比10大,于是不往下找了,而是通过9找到原始链表的9,然后再往后遍历找到了我们要找的10  </p><p> 那如果加二级索引呢？如下图所示，查找路径：1、7、9、10。是不是找 10 的效率更高了？这就是跳表的思想，用“空间换时间”，通过给链表建立索引，提高了查找的效率。 </p><p><img src="http://oss.xiaokoua.cn//Snipaste_2021-10-31_15-27-41.png"></p><p>当数据量足够大时，效率提升会很大。如下图所示，假如有序单链表现在有1万个元素，分别是 0~9999。现在我们建了很多级索引，最高级的索引，就两个元素 0、5000，次高级索引四个元素 0、2500、5000、7500，依次类推，当我们查找 7890 这个元素时，查找路径为 0、5000、7500 … 7890，通过最高级索引直接跳过了5000个元素，次高层索引直接跳过了2500个元素，<strong>从而使得链表能够实现二分查找</strong>。由此可以看出，当元素数量较多时，索引提高的效率比较大，近似于二分查找。  </p><p><img src="http://oss.xiaokoua.cn//Snipaste_2021-10-31_15-29-05.png"></p><p>跳表是<strong>可以实现二分查找的有序链表</strong> </p><p>更多跳表知识访问原链接:<a href="https://www.jianshu.com/p/9d8296562806">跳表</a></p><p>redis只有在两个地方用到了跳跃表,一个是实现有序集合键,另一个是在集群节点中用作内部数据结构  </p><p>redis的跳跃表由  redis.h/zskiplistNode 和 redis.h/zskiplist 两个结构定义，  其中 zskiplistNode 结构用于表示跳跃表节点， 而 zskiplist 结构则用于保存跳跃表节点的相关信息， 比如节点的数量， 以及指向表头节点和表尾节点的指针等  </p><p><img src="http://oss.xiaokoua.cn//Snipaste_2021-10-31_15-39-26.png" alt="redis跳跃表"></p><p>上图展示了一个跳跃表示例,位于图片最左边的是zskiplist结构,该结构包含以下属性:  </p><ul><li>header ：指向跳跃表的表头节点。</li><li>tail ：指向跳跃表的表尾节点。</li><li>level ：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。</li><li>length ：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内）。</li></ul><p> 位于 zskiplist 结构右方的是四个 zskiplistNode 结构， 该结构包含以下属性： </p><ul><li>层（level）：节点中用 L1 、 L2 、 L3 等字样标记节点的各个层， L1 代表第一层， L2 代表第二层，以此类推。每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。在上面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。  </li><li>后退（backward）指针：节点中用 BW 字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。</li><li>分值（score）：各个节点中的 1.0 、 2.0 和 3.0 是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列。</li><li>成员对象（obj）：各个节点中的 o1 、 o2 和 o3 是节点所保存的成员对象。</li></ul><h5 id="跳跃表节点"><a href="#跳跃表节点" class="headerlink" title="跳跃表节点"></a>跳跃表节点</h5><p> 跳跃表节点的实现由 redis.h/zskiplistNode 结构定义： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> &#123;</span><br><br>    <span class="hljs-comment">// 后退指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">backward</span>;</span><br><br>    <span class="hljs-comment">// 分值</span><br>    <span class="hljs-keyword">double</span> score;<br><br>    <span class="hljs-comment">// 成员对象</span><br>    robj *obj;<br><br>    <span class="hljs-comment">// 层</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistLevel</span> &#123;</span><br><br>        <span class="hljs-comment">// 前进指针</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">forward</span>;</span><br><br>        <span class="hljs-comment">// 跨度</span><br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> span;<br><br>    &#125; level[];<br><br>&#125; zskiplistNode;<br></code></pre></td></tr></table></figure><h5 id="层"><a href="#层" class="headerlink" title="层"></a>层</h5><p> 跳跃表节点的 level 数组可以包含多个元素， 每个元素都包含一个指向其他节点的指针， 程序可以通过这些层来加快访问其他节点的速度， 一般来说， 层的数量越多， 访问其他节点的速度就越快。 </p><h5 id="跨度"><a href="#跨度" class="headerlink" title="跨度"></a>跨度</h5><p> 层的跨度（level[i].span 属性）用于记录两个节点之间的距离：  两个节点之间的跨度越大， 它们相距得就越远。 </p><p> 初看上去， 很容易以为跨度和遍历操作有关， 但实际上并不是这样 —— 遍历操作只使用前进指针就可以完成了， 跨度实际上是用来计算排位（rank）的： 在查找某个节点的过程中， 将沿途访问过的所有层的跨度累计起来， 得到的结果就是目标节点在跳跃表中的排位。   </p><p> 举个例子， 下图用虚线标记了在跳跃表中查找分值为 3.0 、 成员对象为 o3 的节点时， 沿途经历的层： 查找的过程只经过了一个层， 并且层的跨度为 3 ， 所以目标节点在跳跃表中的排位为 3 。 </p><p><img src="http://oss.xiaokoua.cn//Snipaste_2021-10-31_15-49-59.png"></p><h5 id="后腿指针"><a href="#后腿指针" class="headerlink" title="后腿指针"></a>后腿指针</h5><p> 节点的后退指针（backward 属性）用于从表尾向表头方向访问节点： 跟可以一次跳过多个节点的前进指针不同， 因为每个节点只有一个后退指针， 所以每次只能后退至前一个节点。 </p><h5 id="分值和对象"><a href="#分值和对象" class="headerlink" title="分值和对象"></a>分值和对象</h5><p> 节点的分值（score 属性）是一个 double 类型的浮点数， 跳跃表中的所有节点都按分值从小到大来排序。 </p><p> 节点的成员对象（obj 属性）是一个指针， 它指向一个字符串对象， 而字符串对象则保存着一个 SDS 值。 </p><p> 在同一个跳跃表中， 各个节点保存的成员对象必须是唯一的， 但是多个节点保存的分值却可以是相同的： 分值相同的节点将按照成员对象在字典序中的大小来进行排序， 成员对象较小的节点会排在前面（靠近表头的方向）， 而成员对象较大的节点则会排在后面（靠近表尾的方向）。  </p><h5 id="zskiplist"><a href="#zskiplist" class="headerlink" title="zskiplist"></a>zskiplist</h5><p> 通过使用一个 zskiplist 结构来持有这些节点， 程序可以更方便地对整个跳跃表进行处理， 比如快速访问跳跃表的表头节点和表尾节点， 又或者快速地获取跳跃表节点的数量（也即是跳跃表的长度）等信息， 如下图所示。 </p><p><img src="http://oss.xiaokoua.cn//Snipaste_2021-10-31_15-53-34.png"></p><p> zskiplist 结构的定义如下： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplist</span> &#123;</span><br><br>    <span class="hljs-comment">// 表头节点和表尾节点</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">header</span>, *<span class="hljs-title">tail</span>;</span><br><br>    <span class="hljs-comment">// 表中节点的数量</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> length;<br><br>    <span class="hljs-comment">// 表中层数最大的节点的层数</span><br>    <span class="hljs-keyword">int</span> level;<br><br>&#125; zskiplist;<br></code></pre></td></tr></table></figure><p> header 和 tail 指针分别指向跳跃表的表头和表尾节点， 通过这两个指针， 程序定位表头节点和表尾节点的复杂度为 O(1) 。 </p><p> 通过使用 length 属性来记录节点的数量， 程序可以在 O(1) 复杂度内返回跳跃表的长度。 </p><h2 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h2><p>整数集合是集合(set)键的底层实现, 当一个集合只包含整数值元素， 并且这个集合的元素数量不多时， Redis 就会使用整数集合作为集合键的底层实现。 </p><p> 举个例子， 如果我们创建一个只包含五个元素的集合键， 并且集合中的所有元素都是整数值， 那么这个集合键的底层实现就会是整数集合： </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">redis&gt; SADD numbers <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">9</span><br>(<span class="hljs-type">integer</span>) <span class="hljs-number">5</span><br><br>redis&gt; <span class="hljs-keyword">OBJECT</span> <span class="hljs-keyword">ENCODING</span> numbers<br>&quot;intset&quot;<br></code></pre></td></tr></table></figure><p> 整数集合（intset）是 Redis 用于保存整数值的集合抽象数据结构， 它可以保存类型为 int16_t 、 int32_t 或者 int64_t 的整数值， 并且保证集合中不会出现重复元素。 </p><p> 每个 intset.h/intset 结构表示一个整数集合： </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">typedef</span> struct <span class="hljs-built_in">int</span><span class="hljs-keyword">set</span> &#123;<br><br>    <span class="hljs-comment">// 编码方式</span><br>    <span class="hljs-built_in">uint</span>32_t encoding;<br><br>    <span class="hljs-comment">// 集合包含的元素数量</span><br>    <span class="hljs-built_in">uint</span>32_t length;<br><br>    <span class="hljs-comment">// 保存元素的数组</span><br>    <span class="hljs-built_in">int</span>8_t contents[];<br><br>&#125; <span class="hljs-built_in">int</span><span class="hljs-keyword">set</span>;<br></code></pre></td></tr></table></figure><p> contents 数组是整数集合的底层实现： 整数集合的每个元素都是 contents 数组的一个数组项（item）， 各个项在数组中按值的大小从小到大有序地排列， 并且数组中不包含任何重复项。   </p><p> length 属性记录了整数集合包含的元素数量， 也即是 contents 数组的长度。 </p><p> 虽然 intset 结构将 contents 属性声明为 int8_t 类型的数组， 但实际上 contents 数组并不保存任何 int8_t 类型的值 —— contents 数组的真正类型取决于 encoding 属性的值：如果 encoding 属性的值为 INTSET_ENC_INT16 ， 那么 contents 就是一个 int16_t 类型的数组， 数组里的每个项都是一个 int16_t 类型的整数值 （最小值为 -32,768 ，最大值为 32,767 ）。   </p><p> 下图是一个包含五个int16_t类型整数值的整数集合。   </p><p><img src="http://oss.xiaokoua.cn//Snipaste_2021-10-31_16-04-00.png"></p><p>每当我们要将一个新元素添加到整数集合里面,并且新元素的类型比整数集合现有的所有元素的类型都要长时,整数集合需要先进行升级,然后才能将新元素添加到整数集合里面.  </p><p>升级整数集合并添加新元素分为三步进行:  </p><ul><li>根据新元素的类型,扩展整数集合底层数组的空间大小,并为新元素分配空间  </li><li>将底层数组现有的所有元素都转换成与新元素相同的类型,并将类型转换后的元素放置到正确的位置上,而且在放置元素的过程中,需要维持底层数组的有序性质不变.  </li><li>将新元素添加到底层数组里面.  </li></ul><p>整数集合不支持降级操作,一旦对数组进行了升级,编码就会一直保持升级后的状态.  </p><h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><p> 压缩列表（ziplist）是列表键和哈希键的底层实现之一。 </p><p> 当一个列表键只包含少量列表项， 并且每个列表项要么就是小整数值， 要么就是长度比较短的字符串， 那么 Redis 就会使用压缩列表来做列表键的底层实现。 </p><p> 比如说， 执行以下命令将创建一个压缩列表实现的列表键： </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">redis&gt; RPUSH lst <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">10086</span> &quot;hello&quot; &quot;world&quot;<br>(<span class="hljs-type">integer</span>) <span class="hljs-number">6</span><br><br>redis&gt; <span class="hljs-keyword">OBJECT</span> <span class="hljs-keyword">ENCODING</span> lst<br>&quot;ziplist&quot;<br></code></pre></td></tr></table></figure><p> 因为列表键里面包含的都是 1 、 3 、 5 、 10086 这样的小整数值， 以及 “hello” 、 “world” 这样的短字符串。 </p><p> 另外， 当一个哈希键只包含少量键值对， 并且每个键值对的键和值要么就是小整数值， 要么就是长度比较短的字符串， 那么 Redis 就会使用压缩列表来做哈希键的底层实现。 </p><p> 举个例子， 执行以下命令将创建一个压缩列表实现的哈希键： </p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pf">redis&gt; HMSET <span class="hljs-keyword">profile</span> <span class="hljs-string">&quot;name&quot;</span> <span class="hljs-string">&quot;Jack&quot;</span> <span class="hljs-string">&quot;age&quot;</span> <span class="hljs-number">28</span> <span class="hljs-string">&quot;job&quot;</span> <span class="hljs-string">&quot;Programmer&quot;</span><br>OK<br><br>redis&gt; OBJECT ENCODING <span class="hljs-keyword">profile</span><br><span class="hljs-string">&quot;ziplist&quot;</span><br></code></pre></td></tr></table></figure><h5 id="压缩列表的构成"><a href="#压缩列表的构成" class="headerlink" title="压缩列表的构成"></a>压缩列表的构成</h5><p> 压缩列表是 Redis 为了节约内存而开发的， 由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。  一个压缩列表可以包含任意多个节点（entry）， 每个节点可以保存一个字节数组或者一个整数值。 </p><p> 下图展示了压缩列表的各个组成部分。 </p><p><img src="http://oss.xiaokoua.cn//Snipaste_2021-10-31_16-14-48.png"></p><ul><li> zlbytes:  记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配， 或者计算 zlend 的位置时使用。 </li><li> zltail : 记录压缩列表表尾节点距离压缩列表的起始地址有多少字节： 通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址。 </li><li> zllen :  记录了压缩列表包含的节点数量： 当这个属性的值小于 UINT16_MAX （65535）时， 这个属性的值就是压缩列表包含节点的数量； 当这个值等于 UINT16_MAX 时， 节点的真实数量需要遍历整个压缩列表才能计算得出。 </li><li> entryX :  压缩列表包含的各个节点，节点的长度由节点保存的内容决定。 </li><li> zlend:  特殊值 0xFF （十进制 255 ），用于标记压缩列表的末端。 </li></ul><h5 id="压缩列表节点的构成"><a href="#压缩列表节点的构成" class="headerlink" title="压缩列表节点的构成"></a>压缩列表节点的构成</h5><p> 每个压缩列表节点都由 previous_entry_length 、 encoding 、 content 三个部分组成， 如下图所示。 </p><p><img src="http://oss.xiaokoua.cn//Snipaste_2021-10-31_16-17-17.png"></p><ul><li>节点的 previous_entry_length 属性以字节为单位， 记录了压缩列表中前一个节点的长度。</li><li>节点的 encoding 属性记录了节点的 content 属性所保存数据的类型以及长度</li><li> 节点的 content 属性负责保存节点的值， 节点值可以是一个字节数组或者整数， 值的类型和长度由节点的 encoding 属性决定。 </li><li>压缩列表是一种为节约内存而开发的顺序型数据结构。</li><li>压缩列表被用作列表键和哈希键的底层实现之一。</li><li>压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值。</li><li>添加新节点到压缩列表， 或者从压缩列表中删除节点， 可能会引发连锁更新操作， 但这种操作出现的几率并不高。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>redis持久化</title>
    <link href="/2021/10/24/redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <url>/2021/10/24/redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>redis支持RDB和AOF两种持久化机制,持久化功能能有效避免因进程退出造成的数据丢失问题</p><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>RDB持久化是把当前进程数据生成快照保存到硬盘的过程,触发RDB持久化过程分为手动触发和自动触发.  </p><p>有两个命令可以用于生成RDB文件,一个是SAVE,另一个是BGSAVE.<br>SAVE命令会阻塞Redis服务器进程,直到RDB文件创建完毕为止,在服务器阻塞期间,服务器不能处理任何命令请求.  </p><p>和SAVE命令阻塞服务器进程的做法不同,BGSAVE命令会派生出一个子进程,然后由子进程创建RDB文件,父进程处理请求,RDB文件的载入工作是在服务区启动时自动执行的,Redis并没有专门用于载入RDB文件的命令.只要redis在启动时检测到RDB文件的存在,就会自动载入RDB文件.  </p><p>如果服务器开启了AOF持久化功能,那么服务器就会优先使用AOF文件来还原数据库状态.<br>只有在AOF持久化功能处于关闭状态时,服务器才会使用RDB文件来还原数据库状态.  </p><p>自动触发RDB的机制:  </p><ol><li>使用save相关配置,如”save m n”.表示m秒内数据集存在n次修改时,自动触发bgsave.(服务器会维护一个dirty属性保存从上次保存RDB后,redis修改次数,还会维护一个lastsave属性保存上次执行保存的时间,通过这两个属性,redis就可以检测保存条件是否满足,reids默认每100ms检测一次).  </li><li>如果从节点执行全量复制操作,主节点自动执行bgsave生成RDB文件并发送给从节点.</li><li>执行debug reload命令重新加载redis时,也会触发save操作.</li><li>默认情况下执行shutdown时,如果没有开启AOF持久化功能则自动执行bgsave.</li></ol><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>除了RDB持久化功能之外,Redis还提供了AOF持久化功能,与RBD持久化通过保存数据库中的键值对来记录数据库状态不同,AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的.  </p><p>AOF会将所有的写命令追加到缓冲区中,AOF缓冲区根据对应的策略向硬盘做同步操作,随着AOF文件越来越大,需要定期对AOF文件进行重写,达到压缩目的(ps:redis也是fork一个子进程执行AOF文件重写功能,AOF文件重写的原理就是读取内存中的键值对,直接对现存键值对进行记录,这样就可以省去从开始到现状经历的各种写操作).  <img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-08-17_20-42-13_1629204146465.png" alt="Snipaste_20210817_204213.png"><br>为了避免子进程在进行AOF重写时,新的写命令导致AOF重写和内存现状不一致的情况,redis设置了AOF重写缓冲区,在主进程fork子进程进行重写任务的开始,新来的命令不仅会进入AOF缓冲区,而且也会进入AOF重写缓冲区,当子进程完成重写工作后,父进程会通知子进程将AOF重写缓冲区的内容写入到新的AOF文件中,这时新的AOF文件将会和当前内存保持一致.  </p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>synchronized</title>
    <link href="/2021/10/24/synchronized/"/>
    <url>/2021/10/24/synchronized/</url>
    
    <content type="html"><![CDATA[<h1 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h1><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p><strong>所谓原子性就是指一个操作或者多个操作,要么全部执行并且执行的过程不会被任何因素打断,要么就都不执行</strong> </p><p>注意:synchronized和volatile特性的最大区别在于原子性,volatile不具备原子性  </p><h3 id="Synchronized使用"><a href="#Synchronized使用" class="headerlink" title="Synchronized使用"></a>Synchronized使用</h3><p>Synchroniezd可以在静态方法,成员方法,成员对象属性上使用,归根结底它上锁的资源只有两类:一个是对象,一个是类.   </p><h3 id="同步原理"><a href="#同步原理" class="headerlink" title="同步原理"></a>同步原理</h3><p>Synchronized在软件层面依赖JVM实现锁,而Juc.Lock在硬件层面依赖特殊的CPU指令.  </p><p>下面看一个Synchronized例子:  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.paddx.test.concurrent;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Method 1 start&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>查看反编译字节码:  </p><p><img src="http://oss.xiaokoua.cn//Snipaste_2021-09-01_07-45-53.png"></p><p>每个对象都有一个监视器锁,当monitor被占用时就会处于锁定状态,获得锁相当于获得了对象的监视器,线程执行monitorenter指令时尝试获取monitor的所有权,过程如下: </p><ol><li>如果monitor的进入数为0,则该线程进入monitor,然后姜进入数设置为1,该线程即为monitor的所有者</li><li>如果线程已经占有该monitor,只是重新进入,则进入monitor的进入数加1 </li><li>如果其他线程已经占用了monitor</li></ol><h2 id="锁的四种状态"><a href="#锁的四种状态" class="headerlink" title="锁的四种状态"></a>锁的四种状态</h2><p>在 synchronized 最初的实现方式是 “阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态切换需要耗费处理器时间，如果同步代码块中内容过于简单，这种切换的时间可能比用户代码执行的时间还长”，这种方式就是 synchronized实现同步最初的方式，这也是当初开发者诟病的地方，这也是在JDK6以前 synchronized效率低下的原因，JDK6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。</p><p>所以目前锁状态一种有四种，从级别由低到高依次是：无锁、偏向锁，轻量级锁，重量级锁，锁状态只能升级，不能降级</p><h2 id="java对象头"><a href="#java对象头" class="headerlink" title="java对象头"></a>java对象头</h2><p>我们以 Hotspot 虚拟机为例，Hopspot 对象头主要包括两部分数据：Mark Word（标记字段） 和 Klass Pointer（类型指针）</p><p>Mark Word：默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。</p><p>Klass Point：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><p>在上面中我们知道了，synchronized 用的锁是存在Java对象头里的，那么具体是存在对象头哪里呢？答案是：存在锁对象的对象头的Mark Word中，那么MarkWord在对象头中到底长什么样，它到底存储了什么呢？</p><p><img src="https://img-blog.csdnimg.cn/20200606113746579.png"></p><p><img src="http://oss.xiaokoua.cn/blog//20200603161323889_1631542568764.png" alt="20200603161323889.png">  </p><p><strong>无锁</strong>：对象头开辟 25bit 的空间用来存储对象的 hashcode ，4bit 用于存放对象分代年龄，1bit 用来存放是否偏向锁的标识位，2bit 用来存放锁标识位为01</p><p><strong>偏向锁</strong>： 在偏向锁中划分更细，还是开辟 25bit 的空间，其中23bit 用来存放线程ID，2bit 用来存放 Epoch，4bit 存放对象分代年龄，1bit 存放是否偏向锁标识， 0表示无锁，1表示偏向锁，锁的标识位还是01</p><p><strong>轻量级锁</strong>：在轻量级锁中直接开辟 30bit 的空间存放指向栈中锁记录的指针，2bit 存放锁的标志位，其标志位为00</p><p><strong>重量级锁</strong>： 在重量级锁中和轻量级锁一样，30bit 的空间用来存放指向重量级锁的指针，2bit 存放锁的标识位，为11</p><p><strong>GC标记</strong>： 开辟30bit 的内存空间却没有占用，2bit 空间存放锁标志位为11。–</p><h3 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h3><p>Monitor可以理解为一个同步工具或者一种同步机制,通常被描述为一个对象,每一个Java对象就有一把看不见的锁,称为内部锁或者Monitor锁.</p><p>Monitor是线程私有的数据结构,每一个线程都有一个可用monitor record列表,同时还有一个全局的可用列表,每一个被锁住的对象都会和一个monitor关联,同时monitor中有一个Owner字段存放拥有该锁的线程唯一标识,表示该锁被这个线程占用.  </p><h3 id="偏向锁的加锁过程"><a href="#偏向锁的加锁过程" class="headerlink" title="偏向锁的加锁过程:"></a>偏向锁的加锁过程:</h3><ol><li>访问Mark Word中偏向锁的标识是否设置成1,锁标志位是否为01,确认为可偏向状态</li><li>如果为可偏向状态,则判断线程ID是否指向当前线程,如果是,进入步骤5,否则进入步骤3</li><li>如果线程ID并未指向当前线程,则通过CAS操作竞争锁,如果竞争成功,则将MArk Word中线程ID设置为当前线程ID,然后执行5;如果竞争失败,执行4.</li><li>如果CAS获取偏向锁失败,则表示有竞争,当到达全局安全点时获得偏向锁的线程被挂起,偏向锁升级为轻量级锁,然后被阻塞在安全点的线程继续往下执行同步代码</li><li>执行同步代码</li></ol><h3 id="轻量锁的加锁过程"><a href="#轻量锁的加锁过程" class="headerlink" title="轻量锁的加锁过程"></a>轻量锁的加锁过程</h3><p>轻量锁是指当锁是偏向锁的时候,却被另外的线程所访问,此时锁就会升级为轻量锁,其他线程会通过自旋的形式尝试获取锁,线程不会阻塞,从而提高性能.</p><p>轻量锁的获取主要分为两种情况: </p><ol><li>当关闭偏向锁功能时</li><li>由于多个线程竞争导致偏向锁升级为轻量级锁</li></ol><p>一旦有第二个线程加入锁竞争,偏向锁就会升级为轻量级锁,竞争是指多个线程轮流获取锁,运气不好,遇到阻塞的情况.  </p><p>在轻量级锁状态下继续竞争,没有抢到锁的线程将自旋,即不停循环判断锁是否能够被成功获取,获取锁<br>的操作就是通过CAS修改对象头里的标志位,先比较当前锁是否未”释放”,如果是将其修改设置为锁定,然后线程将当前锁的持有者信息修改为自己.</p><p>长时间的自旋操作是非常消耗资源的,一个线程持有锁,其他线程就只能在原地空耗CPU,执行不了任何有效的任务,这种现象叫做忙等. </p><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>忙等是有限度的（有个计数器记录自旋次数，默认允许循环10次，可以通过虚拟机参数更改）。如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为重量级锁（依然是CAS修改锁标志位，但不修改持有锁的线程ID）。当后续线程尝试获取锁时，发现被占用的锁是重量级锁，则直接将自己挂起（而不是忙等），等待将来被唤醒。</p><p>重量级锁是指当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态。</p><p>简言之，就是所有的控制权都交给了操作系统，由操作系统来负责线程间的调度和线程的状态变更。而这样会出现频繁地对线程运行状态的切换，线程的挂起和唤醒，从而消耗大量的系统资</p>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MVCC</title>
    <link href="/2021/10/24/MVCC/"/>
    <url>/2021/10/24/MVCC/</url>
    
    <content type="html"><![CDATA[<h3 id="事务并发执行下遇到的问题"><a href="#事务并发执行下遇到的问题" class="headerlink" title="事务并发执行下遇到的问题"></a>事务并发执行下遇到的问题</h3><ul><li><p>脏写<br>如果一个事务修改了另一个未提交事务修改过的数据,就是发生了<strong>脏写</strong>,<br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-09-28_07-28-25_1632785315057.png" alt="Snipaste_20210928_072825.png"><br>sessionA和sessionB各开始了一个事务,如果sessionB中的事务发生了回滚,那么sessionA中的更新也不复存在,这种现象就是脏写 </p></li><li><p>脏读<br>如果一个事务读到了另一个未提交修改过的数据,那就是发生了脏读<br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-09-28_07-32-39_1632785570717.png" alt="Snipaste_20210928_073239.png"><br>sessionB先修改了number为1的数据,在sessionB还未提交事务的时候,sessionA读取了number为1的数据,得到name为’关羽’,那么sessionA就读取到了sessionB还未提交的脏数据</p></li><li><p>不可重复读</p></li></ul><p>如果一个事务只能读到另一个已经提交的的事务修改过的数据,并且其他事务每对该数据进行一次修改并提交后,该事务都能查询到最新值,那么就是发生了不可重复读  </p><p><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-09-28_07-41-17_1632786087192.png" alt="Snipaste_20210928_074117.png">  </p><p>sessionB提交了几个事务(隐式提交,语句结束事务就提交了),每次提交后,sessionA中的事务都可以查看到最新的值,这种现象称为不可重复读.  </p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>redo日志</title>
    <link href="/2021/10/24/redo%E6%97%A5%E5%BF%97/"/>
    <url>/2021/10/24/redo%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h2 id="redo日志是啥"><a href="#redo日志是啥" class="headerlink" title="redo日志是啥"></a>redo日志是啥</h2><p>在真正访问页面之前,需要把在磁盘上的页缓存到Buffer Pool之后才可以访问,但是在事务的持久性的特性中,对于一个已经提交的事务,在事务提交后即使系统崩溃了,这个事务对数据库所做的更改页不能丢失,但是假如事务提交后发生了某个故障,导致内存中的数据都失效了,那么数据库如何做到持久性?  </p><p>我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效,即使后来系统崩溃,在重启后也能把这种修改恢复出来,所以没必要在事务提交时就把该事务在内存中修改的页刷新到磁盘,只需要把修改了哪些东西记录一下就好,那么事务对数据亏所做的修改又可以被恢复,所以上述内容也被称为重做日志(redo log)  </p><p>redo日志的好处如下:  </p><ul><li>redo日志占用的空间非常小  </li><li>redo日志是顺序写入磁盘,在执行事务的过程中,每执行一条语句,就可能产生若干redo 日志,这些日志是按照顺序产生的顺序写入磁盘的,也就是使用顺序IO  </li></ul><h3 id="redo-日志格式"><a href="#redo-日志格式" class="headerlink" title="redo 日志格式"></a>redo 日志格式</h3><p>redo 日志本质上只是记录了一下事务对数据库做了哪些修改,针对事务对数据库的不同修改场景定义了多种类型的 redo 日志，但是绝大部分类型的 redo 日志都有下边这种通用的结构<br><img src="http://oss.xiaokoua.cn/blog//Snipaste_2021-05-23_12-16-41_1621743411311.png" alt="Snipaste_20210523_121641.png">  </p><ul><li>type:该条redo日志的类型 </li><li>space ID:表空间ID </li><li>page number: 页号</li><li>data:该条redo日志的具体内容  </li></ul>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
